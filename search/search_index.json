{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"API Donn\u00e9es fonci\u00e8res \u2014 Client Python","text":"<p>Bienvenue dans la documentation du client Python pour l'API Donn\u00e9es fonci\u00e8res du Cerema.</p> <p>Ce client permet d'interroger facilement les diff\u00e9rents jeux de donn\u00e9es fonci\u00e8res interrogeables via l'API, notamment :</p> <ul> <li>les mutations fonci\u00e8res et immobili\u00e8res issues de DVF+ (ouvert) et de DV3F (restriction d'acc\u00e8s)</li> <li>les donn\u00e9es des Fichiers fonciers (parcelles, locaux, TUPs, propri\u00e9taires)</li> <li>les donn\u00e9es sur les friches issues de Cartofriches</li> <li>les indicateurs territoriaux (consommation d'espace, march\u00e9 immobilier, etc.)</li> </ul>"},{"location":"#structure-de-la-documentation","title":"Structure de la documentation","text":"<ul> <li>Quickstart\u202f: comment installer le package et l'utiliser</li> <li>Endpoints\u202f: documentation des endpoints, ouverts et \u00e0 acc\u00e8s restreint, disponibles</li> <li>Galerie d'exemples\u202f: notebooks avec des exemples d\u2019usage</li> </ul>"},{"location":"#acces-restreint","title":"Acc\u00e8s restreint","text":"<p>Certains endpoints n\u00e9cessitent un jeton API Cerema disponible via le Portail Donn\u00e9es fonci\u00e8res.</p> <p>Pour en obtenir un\u202f: https://portaildf.cerema.fr</p>"},{"location":"#support","title":"Support","text":"<p>Pour toute question ou retour\u202f: Contact Cerema</p>"},{"location":"endpoints/cartofriches/","title":"Cartofriches - principaux endpoints","text":"<p>Permet d'interroger les friches et leurs g\u00e9om\u00e9tries.</p>"},{"location":"endpoints/cartofriches/#cartofrichesfriches","title":"\ud83d\udcc2 <code>cartofriches.friches</code>","text":""},{"location":"endpoints/cartofriches/#description","title":"Description","text":"<p>Retourne les friches issues de Cartofriches pour la commune, le d\u00e9partement ou l'emprise rectangulaire demand\u00e9e.</p> <p>Parameters:</p> Name Type Description Default <code>code_insee</code> <code>(str, obligatoire)</code> <p>Code INSEE communal ou d'arrondissement municipal (max 10, s\u00e9par\u00e9s par virgule).</p> <code>None</code> <code>codes_insee</code> <code>(List[str], optionnel)</code> <p>Liste de codes INSEE.</p> <code>None</code> <code>coddep</code> <code>(str, obligatoire)</code> <p>Code INSEE d\u00e9partemental.</p> <code>None</code> <code>in_bbox</code> <code>(List[float], obligatoire)</code> <p>[xmin, ymin, xmax, ymax], max 1.0\u00b0 x 1.0\u00b0.</p> <code>None</code> <code>lon_lat</code> <code>(List[float], optionnel)</code> <p>Coordonn\u00e9es [lon, lat].</p> <code>None</code> <code>contains_lon_lat</code> <code>(List[float], optionnel)</code> <p>Coordonn\u00e9es \u00e0 contenir [lon, lat].</p> <code>None</code> <code>surface_min</code> <code>(float, optionnel)</code> <p>Surface minimale de l'unit\u00e9 fonci\u00e8re.</p> <code>None</code> <code>surface_max</code> <code>(float, optionnel)</code> <p>Surface maximale de l'unit\u00e9 fonci\u00e8re.</p> <code>None</code> <code>urba_zone_type</code> <code>(str, optionnel)</code> <p>Type de zone d'urbanisme.</p> <code>None</code> <code>fields</code> <code>(str, optionnel)</code> <p>'all' pour obtenir tous les champs, None sinon.</p> <code>None</code> <code>ordering</code> <code>(str, optionnel)</code> <p>Champ de tri.</p> <code>None</code> <code>page</code> <code>(int, optionnel)</code> <p>Page de r\u00e9sultats.</p> <code>None</code> <code>page_size</code> <code>(int, optionnel)</code> <p>Nombre de r\u00e9sultats par page.</p> <code>500</code> <code>paginate</code> <code>(bool, optionnel)</code> <p>Pagination automatique.</p> <code>True</code> <code>format_output</code> <code>(str, optionnel)</code> <p>'dataframe' ou 'dict'.</p> <code>'dataframe'</code> <p>Returns:</p> Type Description <code>Union[DataFrame, List[dict]]</code> <p>DataFrame ou liste de dictionnaires des friches.</p> Source code in <code>apifoncier\\endpoints\\cartofriches.py</code> <pre><code>def friches(\n    self,\n    code_insee: Optional[str] = None,\n    codes_insee: Optional[List[str]] = None,\n    coddep: Optional[str] = None,\n    in_bbox: Optional[List[float]] = None,\n    lon_lat: Optional[List[float]] = None,\n    contains_lon_lat: Optional[List[float]] = None,\n    surface_min: Optional[float] = None,\n    surface_max: Optional[float] = None,\n    urba_zone_type: Optional[str] = None,\n    fields: Optional[str] = None,\n    ordering: Optional[str] = None,\n    page: Optional[int] = None,\n    page_size: Optional[int] = 500,\n    paginate: bool = True,\n    format_output: str = \"dataframe\",\n) -&gt; Union[pd.DataFrame, List[dict]]:\n    \"\"\"\n    Retourne les friches issues de Cartofriches pour la commune, le d\u00e9partement ou l'emprise rectangulaire demand\u00e9e.\n\n    Args:\n        code_insee (str, obligatoire): Code INSEE communal ou d'arrondissement municipal (max 10, s\u00e9par\u00e9s par virgule).\n        codes_insee (List[str], optionnel): Liste de codes INSEE.\n        coddep (str, obligatoire): Code INSEE d\u00e9partemental.\n        in_bbox (List[float], obligatoire): [xmin, ymin, xmax, ymax], max 1.0\u00b0 x 1.0\u00b0.\n        lon_lat (List[float], optionnel): Coordonn\u00e9es [lon, lat].\n        contains_lon_lat (List[float], optionnel): Coordonn\u00e9es \u00e0 contenir [lon, lat].\n        surface_min (float, optionnel): Surface minimale de l'unit\u00e9 fonci\u00e8re.\n        surface_max (float, optionnel): Surface maximale de l'unit\u00e9 fonci\u00e8re.\n        urba_zone_type (str, optionnel): Type de zone d'urbanisme.\n        fields (str, optionnel): 'all' pour obtenir tous les champs, None sinon.\n        ordering (str, optionnel): Champ de tri.\n        page (int, optionnel): Page de r\u00e9sultats.\n        page_size (int, optionnel): Nombre de r\u00e9sultats par page.\n        paginate (bool, optionnel): Pagination automatique.\n        format_output (str, optionnel): 'dataframe' ou 'dict'.\n\n    Returns:\n        DataFrame ou liste de dictionnaires des friches.\n    \"\"\"\n    # Validation des param\u00e8tres de localisation avec mutualisation\n    checked_codes_insee, bbox_result, auto_contains_geom = (\n        self._validate_location_params(\n            code_insee=code_insee,\n            codes_insee=codes_insee,\n            coddep=coddep,\n            in_bbox=in_bbox,\n            lon_lat=lon_lat,\n            contains_lon_lat=contains_lon_lat,\n            max_bbox_size=1.0,  # Cartofriches autorise 1.0\u00b0 vs 0.02\u00b0 pour DVF\n            max_interval=0.5,  # Intervalle pour lon_lat\n            max_codes=10,\n        )\n    )\n\n    # Construction des param\u00e8tres\n    params = self._build_params(\n        code_insee=checked_codes_insee,\n        coddep=coddep,\n        in_bbox=\",\".join(map(str, bbox_result)) if bbox_result else None,\n        contains_geom=auto_contains_geom,\n        surface_min=surface_min,\n        surface_max=surface_max,\n        urba_zone_type=urba_zone_type,\n        fields=fields,\n        ordering=ordering,\n        page=page,\n        page_size=page_size,\n    )\n\n    return self._fetch(\n        endpoint=\"/cartofriches/friches\",\n        params=params,\n        format_output=format_output,\n        geo=False,\n        paginate=paginate,\n    )\n</code></pre>"},{"location":"endpoints/cartofriches/#exemples-dutilisation","title":"Exemples d'utilisation","text":"<ul> <li> <p>Friches d'une commune :   <pre><code># Initialisation du client\nfrom apifoncier import ApiFoncierClient\n\nclient = ApiFoncierClient()\n\n# Requ\u00eate pour les friches d'une commune\nfriches = client.cartofriches.friches(code_insee=\"59350\")\n</code></pre></p> </li> <li> <p>Friches d'un d\u00e9partement :   <pre><code># Requ\u00eate pour les friches d'un d\u00e9partement\nfriches = client.cartofriches.friches(coddep=\"62\")\n</code></pre></p> </li> <li> <p>Friches dans une emprise g\u00e9ographique :   <pre><code># Requ\u00eate pour les friches dans une emprise g\u00e9ographique\nfriches = client.cartofriches.friches(in_bbox=[2.76, 49.73, 3.75, 50.6])\n</code></pre></p> </li> <li> <p>Friches autour d'un point <pre><code>  # Requ\u00eate pour les friches \u00e0 proximit\u00e9 d'un point (emprise rectangulaire de 0.5\u00b0 autour du point)\n  client.cartofriches.friches(lon_lat=[2.8, 49.75])\n</code></pre></p> </li> <li> <p>Friches avec filtres - surface entre 1000 et 5000 m\u00b2, zone urbaine de type \"U\" :   <pre><code># Friches avec filtres\nfriches = client.cartofriches.friches(\n    code_insee=\"59350\",\n    surface_min=1000,\n    surface_max=5000,\n    urba_zone_type=\"U\",\n    fields=\"all\", # R\u00e9cup\u00e8re tous les champs disponibles\n)\n</code></pre></p> </li> </ul>"},{"location":"endpoints/cartofriches/#cartofrichesgeofriches","title":"\ud83d\udcc2 <code>cartofriches.geofriches</code>","text":""},{"location":"endpoints/cartofriches/#description_1","title":"Description","text":"<p>Retourne, en GeoJSON, les friches issues de Cartofriches pour la commune, le d\u00e9partement ou l'emprise rectangulaire demand\u00e9e.</p> <p>Parameters:</p> Name Type Description Default <code>code_insee</code> <code>(str, obligatoire)</code> <p>Code INSEE communal ou d'arrondissement municipal (max 10, s\u00e9par\u00e9s par virgule).</p> <code>None</code> <code>codes_insee</code> <code>(List[str], optionnel)</code> <p>Liste de codes INSEE.</p> <code>None</code> <code>coddep</code> <code>(str, obligatoire)</code> <p>Code INSEE d\u00e9partemental.</p> <code>None</code> <code>in_bbox</code> <code>(List[float], obligatoire)</code> <p>[xmin, ymin, xmax, ymax], max 1.0\u00b0 x 1.0\u00b0.</p> <code>None</code> <code>lon_lat</code> <code>(List[float], optionnel)</code> <p>Coordonn\u00e9es [lon, lat].</p> <code>None</code> <code>contains_lon_lat</code> <code>(List[float], optionnel)</code> <p>Coordonn\u00e9es \u00e0 contenir [lon, lat].</p> <code>None</code> <code>surface_min</code> <code>(float, optionnel)</code> <p>Surface minimale de l'unit\u00e9 fonci\u00e8re.</p> <code>None</code> <code>surface_max</code> <code>(float, optionnel)</code> <p>Surface maximale de l'unit\u00e9 fonci\u00e8re.</p> <code>None</code> <code>urba_zone_type</code> <code>(str, optionnel)</code> <p>Type de zone d'urbanisme.</p> <code>None</code> <code>fields</code> <code>(str, optionnel)</code> <p>'all' pour obtenir tous les champs, None sinon.</p> <code>None</code> <code>page</code> <code>(int, optionnel)</code> <p>Page de r\u00e9sultats.</p> <code>None</code> <code>page_size</code> <code>(int, optionnel)</code> <p>Nombre de r\u00e9sultats par page.</p> <code>500</code> <code>paginate</code> <code>(bool, optionnel)</code> <p>Pagination automatique.</p> <code>True</code> <code>format_output</code> <code>(str, optionnel)</code> <p>'dataframe' ou 'dict'.</p> <code>'dataframe'</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>GeoDataFrame des friches g\u00e9olocalis\u00e9es.</p> Source code in <code>apifoncier\\endpoints\\cartofriches.py</code> <pre><code>def geofriches(\n    self,\n    code_insee: Optional[str] = None,\n    codes_insee: Optional[List[str]] = None,\n    coddep: Optional[str] = None,\n    in_bbox: Optional[List[float]] = None,\n    lon_lat: Optional[List[float]] = None,\n    contains_lon_lat: Optional[List[float]] = None,\n    surface_min: Optional[float] = None,\n    surface_max: Optional[float] = None,\n    urba_zone_type: Optional[str] = None,\n    fields: Optional[str] = None,\n    page: Optional[int] = None,\n    page_size: Optional[int] = 500,\n    paginate: bool = True,\n    format_output: str = \"dataframe\",\n) -&gt; gpd.GeoDataFrame:\n    \"\"\"\n    Retourne, en GeoJSON, les friches issues de Cartofriches pour la commune, le d\u00e9partement ou l'emprise rectangulaire demand\u00e9e.\n\n    Args:\n        code_insee (str, obligatoire): Code INSEE communal ou d'arrondissement municipal (max 10, s\u00e9par\u00e9s par virgule).\n        codes_insee (List[str], optionnel): Liste de codes INSEE.\n        coddep (str, obligatoire): Code INSEE d\u00e9partemental.\n        in_bbox (List[float], obligatoire): [xmin, ymin, xmax, ymax], max 1.0\u00b0 x 1.0\u00b0.\n        lon_lat (List[float], optionnel): Coordonn\u00e9es [lon, lat].\n        contains_lon_lat (List[float], optionnel): Coordonn\u00e9es \u00e0 contenir [lon, lat].\n        surface_min (float, optionnel): Surface minimale de l'unit\u00e9 fonci\u00e8re.\n        surface_max (float, optionnel): Surface maximale de l'unit\u00e9 fonci\u00e8re.\n        urba_zone_type (str, optionnel): Type de zone d'urbanisme.\n        fields (str, optionnel): 'all' pour obtenir tous les champs, None sinon.\n        page (int, optionnel): Page de r\u00e9sultats.\n        page_size (int, optionnel): Nombre de r\u00e9sultats par page.\n        paginate (bool, optionnel): Pagination automatique.\n        format_output (str, optionnel): 'dataframe' ou 'dict'.\n\n    Returns:\n        GeoDataFrame des friches g\u00e9olocalis\u00e9es.\n    \"\"\"\n    # Validation des param\u00e8tres (r\u00e9utilisation du code)\n    checked_codes_insee, bbox_result, auto_contains_geom = (\n        self._validate_location_params(\n            code_insee=code_insee,\n            codes_insee=codes_insee,\n            coddep=coddep,\n            in_bbox=in_bbox,\n            lon_lat=lon_lat,\n            contains_lon_lat=contains_lon_lat,\n            max_bbox_size=1.0,\n            max_interval=0.5,  # Intervalle pour lon_lat\n            max_codes=10,\n        )\n    )\n\n    # Construction des param\u00e8tres\n    params = self._build_params(\n        code_insee=checked_codes_insee,\n        coddep=coddep,\n        in_bbox=\",\".join(map(str, bbox_result)) if bbox_result else None,\n        contains_geom=auto_contains_geom,\n        surface_min=surface_min,\n        surface_max=surface_max,\n        urba_zone_type=urba_zone_type,\n        fields=fields,\n        page=page,\n        page_size=page_size,\n    )\n\n    return self._fetch(\n        endpoint=\"/cartofriches/geofriches\",\n        params=params,\n        format_output=format_output,\n        geo=True,\n        paginate=paginate,\n    )\n</code></pre>"},{"location":"endpoints/cartofriches/#exemples-dutilisation_1","title":"Exemples d'utilisation","text":"<ul> <li>Friches g\u00e9olocalis\u00e9es d'une commune :   <pre><code>client.cartofriches.geofriches(code_insee=\"59350\")\n</code></pre></li> <li>Friches g\u00e9olocalis\u00e9es d'un d\u00e9partement :   <pre><code>client.cartofriches.geofriches(coddep=\"62\")\n</code></pre></li> <li>Friches g\u00e9olocalis\u00e9es avec filtre sur zone urbaine :   <pre><code>client.cartofriches.geofriches(code_insee=\"59350\", urba_zone_type=\"U\")\n</code></pre></li> </ul>"},{"location":"endpoints/cartofriches/#cartofrichesfriche_by_id","title":"\ud83d\udcc2 <code>cartofriches.friche_by_id</code>","text":""},{"location":"endpoints/cartofriches/#description_2","title":"Description","text":"<p>Retourne la friche pour l'identifiant de site demand\u00e9.</p> <p>Parameters:</p> Name Type Description Default <code>site_id</code> <code>(str, obligatoire)</code> <p>Identifiant unique du site.</p> required <code>format_output</code> <code>(str, optionnel)</code> <p>'dict'.</p> <code>'dict'</code> <p>Returns:</p> Type Description <code>Union[dict, List[dict]]</code> <p>D\u00e9tails de la friche.</p> Source code in <code>apifoncier\\endpoints\\cartofriches.py</code> <pre><code>def friche_by_id(\n    self, site_id: str, format_output: str = \"dict\"\n) -&gt; Union[dict, List[dict]]:\n    \"\"\"\n    Retourne la friche pour l'identifiant de site demand\u00e9.\n\n    Args:\n        site_id (str, obligatoire): Identifiant unique du site.\n        format_output (str, optionnel): 'dict'.\n\n    Returns:\n        D\u00e9tails de la friche.\n    \"\"\"\n    if not site_id:\n        raise ValidationError(\"site_id est obligatoire\")\n\n    # Pas de pagination pour une friche unique\n    return self._fetch(\n        endpoint=f\"/cartofriches/friches/{site_id}\",\n        params={},\n        format_output=format_output,\n        geo=False,\n        paginate=False,\n    )\n</code></pre>"},{"location":"endpoints/cartofriches/#exemples-dutilisation_2","title":"Exemples d'utilisation","text":"<ul> <li>Friche par identifiant :   <pre><code>client.cartofriches.friche_by_id(site_id=\"59350_991\")\n</code></pre></li> </ul>"},{"location":"endpoints/dv3f/","title":"DV3F - principaux endpoints","text":"<p>Permet d'interroger les mutations DV3F et leurs g\u00e9om\u00e9tries.</p>"},{"location":"endpoints/dv3f/#clef-api","title":"Clef API","text":"<p>Une cl\u00e9 API est requise pour acc\u00e9der aux endpoints DV3F. Vous pouvez obtenir une cl\u00e9 via le Portail Donn\u00e9es fonci\u00e8res.</p> <pre><code>from apifoncier.client import ApiFoncierClient\n\napi_key = \"VOTRE_CLE_API\"  # Cl\u00e9 API requise pour acc\u00e9der aux endpoints DV3F\nclient = ApiFoncierClient({\"api_key\": api_key})\n</code></pre>"},{"location":"endpoints/dv3f/#dv3fmutations","title":"\ud83d\udcc2 <code>dv3f.mutations</code>","text":""},{"location":"endpoints/dv3f/#description","title":"Description","text":"<p>Retourne les mutations issues de DV3F pour la commune ou l'emprise rectangulaire demand\u00e9e.</p> <p>Parameters:</p> Name Type Description Default <code>code_insee</code> <code>(str, optionnel)</code> <p>Code INSEE communal ou d'arrondissement municipal (max 10, s\u00e9par\u00e9s par virgule).</p> <code>None</code> <code>codes_insee</code> <code>(List[str], optionnel)</code> <p>Liste de codes INSEE.</p> <code>None</code> <code>in_bbox</code> <code>(List[float], optionnel)</code> <p>[xmin, ymin, xmax, ymax], max 0.02\u00b0 x 0.02\u00b0.</p> <code>None</code> <code>lon_lat</code> <code>(List[float], optionnel)</code> <p>Coordonn\u00e9es [lon, lat].</p> <code>None</code> <code>contains_lon_lat</code> <code>(List[float], optionnel)</code> <p>Coordonn\u00e9es \u00e0 contenir [lon, lat].</p> <code>None</code> <code>anneemut</code> <code>(str, optionnel)</code> <p>Ann\u00e9e de mutation (&gt;=2010).</p> <code>None</code> <code>anneemut_min</code> <code>(str, optionnel)</code> <p>Ann\u00e9e minimale.</p> <code>None</code> <code>anneemut_max</code> <code>(str, optionnel)</code> <p>Ann\u00e9e maximale.</p> <code>None</code> <code>codtypbien</code> <code>(str, optionnel)</code> <p>Typologie de bien (s\u00e9par\u00e9s par virgule).</p> <code>None</code> <code>idnatmut</code> <code>(str, optionnel)</code> <p>Nature de mutation (s\u00e9par\u00e9s par virgule).</p> <code>None</code> <code>vefa</code> <code>(str, optionnel)</code> <p>Vente en l'\u00e9tat futur d'ach\u00e8vement.</p> <code>None</code> <code>codtypproa</code> <code>(str, optionnel)</code> <p>Typologie acheteur (s\u00e9par\u00e9s par virgule).</p> <code>None</code> <code>codtypprov</code> <code>(str, optionnel)</code> <p>Typologie vendeur (s\u00e9par\u00e9s par virgule).</p> <code>None</code> <code>filtre</code> <code>(str, optionnel)</code> <p>Code pour exclure des transactions particuli\u00e8res.</p> <code>None</code> <code>segmtab</code> <code>(str, optionnel)</code> <p>Note de segment terrain \u00e0 b\u00e2tir.</p> <code>None</code> <code>sbati_min</code> <code>(float, optionnel)</code> <p>Surface b\u00e2tie minimale.</p> <code>None</code> <code>sbati_max</code> <code>(float, optionnel)</code> <p>Surface b\u00e2tie maximale.</p> <code>None</code> <code>sterr_min</code> <code>(float, optionnel)</code> <p>Surface terrain minimale.</p> <code>None</code> <code>sterr_max</code> <code>(float, optionnel)</code> <p>Surface terrain maximale.</p> <code>None</code> <code>valeurfonc_min</code> <code>(float, optionnel)</code> <p>Valeur fonci\u00e8re minimale (\u20ac).</p> <code>None</code> <code>valeurfonc_max</code> <code>(float, optionnel)</code> <p>Valeur fonci\u00e8re maximale (\u20ac).</p> <code>None</code> <code>fields</code> <code>(str, optionnel)</code> <p>'all' pour obtenir tous les champs, None sinon.</p> <code>None</code> <code>ordering</code> <code>(str, optionnel)</code> <p>Champ de tri.</p> <code>None</code> <code>page</code> <code>(int, optionnel)</code> <p>Page de r\u00e9sultats.</p> <code>None</code> <code>page_size</code> <code>(int, optionnel)</code> <p>Nombre de r\u00e9sultats par page.</p> <code>500</code> <code>paginate</code> <code>(bool, optionnel)</code> <p>Pagination automatique.</p> <code>True</code> <code>format_output</code> <code>(str, optionnel)</code> <p>'dataframe' ou 'dict'.</p> <code>'dataframe'</code> <p>Returns:</p> Type Description <code>Union[DataFrame, List[dict]]</code> <p>DataFrame ou liste de dictionnaires des mutations.</p> Source code in <code>apifoncier\\endpoints\\dv3f.py</code> <pre><code>def mutations(\n    self,\n    code_insee: Optional[str] = None,\n    codes_insee: Optional[List[str]] = None,\n    in_bbox: Optional[List[float]] = None,\n    lon_lat: Optional[List[float]] = None,\n    contains_lon_lat: Optional[List[float]] = None,\n    anneemut: Optional[str] = None,\n    anneemut_min: Optional[str] = None,\n    anneemut_max: Optional[str] = None,\n    codtypbien: Optional[str] = None,\n    idnatmut: Optional[str] = None,\n    vefa: Optional[str] = None,\n    codtypproa: Optional[str] = None,\n    codtypprov: Optional[str] = None,\n    filtre: Optional[str] = None,\n    segmtab: Optional[str] = None,\n    sbati_min: Optional[float] = None,\n    sbati_max: Optional[float] = None,\n    sterr_min: Optional[float] = None,\n    sterr_max: Optional[float] = None,\n    valeurfonc_min: Optional[float] = None,\n    valeurfonc_max: Optional[float] = None,\n    fields: Optional[str] = None,\n    ordering: Optional[str] = None,\n    page: Optional[int] = None,\n    page_size: Optional[int] = 500,\n    paginate: bool = True,\n    format_output: str = \"dataframe\",\n) -&gt; Union[pd.DataFrame, List[dict]]:\n    \"\"\"\n    Retourne les mutations issues de DV3F pour la commune ou l'emprise rectangulaire demand\u00e9e.\n\n    Args:\n        code_insee (str, optionnel): Code INSEE communal ou d'arrondissement municipal (max 10, s\u00e9par\u00e9s par virgule).\n        codes_insee (List[str], optionnel): Liste de codes INSEE.\n        in_bbox (List[float], optionnel): [xmin, ymin, xmax, ymax], max 0.02\u00b0 x 0.02\u00b0.\n        lon_lat (List[float], optionnel): Coordonn\u00e9es [lon, lat].\n        contains_lon_lat (List[float], optionnel): Coordonn\u00e9es \u00e0 contenir [lon, lat].\n        anneemut (str, optionnel): Ann\u00e9e de mutation (&gt;=2010).\n        anneemut_min (str, optionnel): Ann\u00e9e minimale.\n        anneemut_max (str, optionnel): Ann\u00e9e maximale.\n        codtypbien (str, optionnel): Typologie de bien (s\u00e9par\u00e9s par virgule).\n        idnatmut (str, optionnel): Nature de mutation (s\u00e9par\u00e9s par virgule).\n        vefa (str, optionnel): Vente en l'\u00e9tat futur d'ach\u00e8vement.\n        codtypproa (str, optionnel): Typologie acheteur (s\u00e9par\u00e9s par virgule).\n        codtypprov (str, optionnel): Typologie vendeur (s\u00e9par\u00e9s par virgule).\n        filtre (str, optionnel): Code pour exclure des transactions particuli\u00e8res.\n        segmtab (str, optionnel): Note de segment terrain \u00e0 b\u00e2tir.\n        sbati_min (float, optionnel): Surface b\u00e2tie minimale.\n        sbati_max (float, optionnel): Surface b\u00e2tie maximale.\n        sterr_min (float, optionnel): Surface terrain minimale.\n        sterr_max (float, optionnel): Surface terrain maximale.\n        valeurfonc_min (float, optionnel): Valeur fonci\u00e8re minimale (\u20ac).\n        valeurfonc_max (float, optionnel): Valeur fonci\u00e8re maximale (\u20ac).\n        fields (str, optionnel): 'all' pour obtenir tous les champs, None sinon.\n        ordering (str, optionnel): Champ de tri.\n        page (int, optionnel): Page de r\u00e9sultats.\n        page_size (int, optionnel): Nombre de r\u00e9sultats par page.\n        paginate (bool, optionnel): Pagination automatique.\n        format_output (str, optionnel): 'dataframe' ou 'dict'.\n\n    Returns:\n        DataFrame ou liste de dictionnaires des mutations.\n    \"\"\"\n    checked_codes_insee, bbox_result, auto_contains_geom = (\n        self._validate_location_params(\n            code_insee=code_insee,\n            codes_insee=codes_insee,\n            coddep=None,\n            in_bbox=in_bbox,\n            lon_lat=lon_lat,\n            contains_lon_lat=contains_lon_lat,\n            max_bbox_size=0.02,\n            max_codes=10,\n        )\n    )\n    params = self._build_params(\n        code_insee=checked_codes_insee,\n        in_bbox=\",\".join(map(str, bbox_result)) if bbox_result else None,\n        contains_geom=auto_contains_geom,\n        anneemut=anneemut,\n        anneemut_min=anneemut_min,\n        anneemut_max=anneemut_max,\n        codtypbien=codtypbien,\n        idnatmut=idnatmut,\n        vefa=vefa,\n        codtypproa=codtypproa,\n        codtypprov=codtypprov,\n        filtre=filtre,\n        segmtab=segmtab,\n        sbati_min=sbati_min,\n        sbati_max=sbati_max,\n        sterr_min=sterr_min,\n        sterr_max=sterr_max,\n        valeurfonc_min=valeurfonc_min,\n        valeurfonc_max=valeurfonc_max,\n        fields=fields,\n        ordering=ordering,\n        page=page,\n        page_size=page_size,\n    )\n    return self._fetch(\n        endpoint=\"/dv3f/mutations\",\n        params=params,\n        format_output=format_output,\n        geo=False,\n        paginate=paginate,\n    )\n</code></pre>"},{"location":"endpoints/dv3f/#exemples-dutilisation","title":"Exemples d'utilisation","text":"<ul> <li> <p>Mutations DV3F pour une commune :   <pre><code>client.dv3f.mutations(code_insee=\"59001\")\n</code></pre></p> </li> <li> <p>Mutations DV3F dans une emprise g\u00e9ographique :   <pre><code>client.dv3f.mutations(in_bbox=[2.76, 49.73, 2.779, 49.749])\n</code></pre></p> </li> <li> <p>Mutations DV3F pour plusieurs communes :   <pre><code>client.dv3f.mutations(codes_insee=[\"59001\", \"62001\"])\n</code></pre></p> </li> <li> <p>Mutations DV3F pour une commune donn\u00e9e (ici, via le code INSEE 59350) en 2022, pour des biens de type maison ancienne(codtypbien=1113) et dont la surface est comprise entre 1000 et 5000 m2, en r\u00e9cup\u00e9rant tous les champs disponibles :</p> </li> </ul> <pre><code>client.dvf_opendata.mutations(\n    code_insee=\"59350\",\n    anneemut=\"2022\",\n    fields=\"all\",\n    sterr_min=1000,\n    sterr_max=5000,\n    codtypbien=\"1113\",\n)\n</code></pre>"},{"location":"endpoints/dv3f/#dv3fgeomutations","title":"\ud83d\udcc2 <code>dv3f.geomutations</code>","text":""},{"location":"endpoints/dv3f/#description_1","title":"Description","text":"<p>Retourne, en GeoJSON, les mutations issues de DV3F pour la commune ou l'emprise rectangulaire demand\u00e9e.</p> <p>Parameters:</p> Name Type Description Default <code>code_insee</code> <code>(str, optionnel)</code> <p>Code INSEE communal ou d'arrondissement municipal (max 10, s\u00e9par\u00e9s par virgule).</p> <code>None</code> <code>codes_insee</code> <code>(List[str], optionnel)</code> <p>Liste de codes INSEE.</p> <code>None</code> <code>in_bbox</code> <code>(List[float], optionnel)</code> <p>[xmin, ymin, xmax, ymax], max 0.02\u00b0 x 0.02\u00b0.</p> <code>None</code> <code>lon_lat</code> <code>(List[float], optionnel)</code> <p>Coordonn\u00e9es [lon, lat].</p> <code>None</code> <code>contains_lon_lat</code> <code>(List[float], optionnel)</code> <p>Coordonn\u00e9es \u00e0 contenir [lon, lat].</p> <code>None</code> <code>anneemut</code> <code>(str, optionnel)</code> <p>Ann\u00e9e de mutation (&gt;=2010).</p> <code>None</code> <code>anneemut_min</code> <code>(str, optionnel)</code> <p>Ann\u00e9e minimale.</p> <code>None</code> <code>anneemut_max</code> <code>(str, optionnel)</code> <p>Ann\u00e9e maximale.</p> <code>None</code> <code>codtypbien</code> <code>(str, optionnel)</code> <p>Typologie de bien (s\u00e9par\u00e9s par virgule).</p> <code>None</code> <code>idnatmut</code> <code>(str, optionnel)</code> <p>Nature de mutation (s\u00e9par\u00e9s par virgule).</p> <code>None</code> <code>vefa</code> <code>(str, optionnel)</code> <p>Vente en l'\u00e9tat futur d'ach\u00e8vement.</p> <code>None</code> <code>codtypproa</code> <code>(str, optionnel)</code> <p>Typologie acheteur (s\u00e9par\u00e9s par virgule).</p> <code>None</code> <code>codtypprov</code> <code>(str, optionnel)</code> <p>Typologie vendeur (s\u00e9par\u00e9s par virgule).</p> <code>None</code> <code>filtre</code> <code>(str, optionnel)</code> <p>Code pour exclure des transactions particuli\u00e8res.</p> <code>None</code> <code>segmtab</code> <code>(str, optionnel)</code> <p>Note de segment terrain \u00e0 b\u00e2tir.</p> <code>None</code> <code>sbati_min</code> <code>(float, optionnel)</code> <p>Surface b\u00e2tie minimale.</p> <code>None</code> <code>sbati_max</code> <code>(float, optionnel)</code> <p>Surface b\u00e2tie maximale.</p> <code>None</code> <code>sterr_min</code> <code>(float, optionnel)</code> <p>Surface terrain minimale.</p> <code>None</code> <code>sterr_max</code> <code>(float, optionnel)</code> <p>Surface terrain maximale.</p> <code>None</code> <code>valeurfonc_min</code> <code>(float, optionnel)</code> <p>Valeur fonci\u00e8re minimale (\u20ac).</p> <code>None</code> <code>valeurfonc_max</code> <code>(float, optionnel)</code> <p>Valeur fonci\u00e8re maximale (\u20ac).</p> <code>None</code> <code>fields</code> <code>(str, optionnel)</code> <p>'all' pour obtenir tous les champs, None sinon.</p> <code>None</code> <code>page</code> <code>(int, optionnel)</code> <p>Page de r\u00e9sultats.</p> <code>None</code> <code>page_size</code> <code>(int, optionnel)</code> <p>Nombre de r\u00e9sultats par page.</p> <code>500</code> <code>paginate</code> <code>(bool, optionnel)</code> <p>Pagination automatique.</p> <code>True</code> <code>format_output</code> <code>(str, optionnel)</code> <p>'dataframe' ou 'dict'.</p> <code>'dataframe'</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>GeoDataFrame des mutations g\u00e9olocalis\u00e9es.</p> Source code in <code>apifoncier\\endpoints\\dv3f.py</code> <pre><code>def geomutations(\n    self,\n    code_insee: Optional[str] = None,\n    codes_insee: Optional[List[str]] = None,\n    in_bbox: Optional[List[float]] = None,\n    lon_lat: Optional[List[float]] = None,\n    contains_lon_lat: Optional[List[float]] = None,\n    anneemut: Optional[str] = None,\n    anneemut_min: Optional[str] = None,\n    anneemut_max: Optional[str] = None,\n    codtypbien: Optional[str] = None,\n    idnatmut: Optional[str] = None,\n    vefa: Optional[str] = None,\n    codtypproa: Optional[str] = None,\n    codtypprov: Optional[str] = None,\n    filtre: Optional[str] = None,\n    segmtab: Optional[str] = None,\n    sbati_min: Optional[float] = None,\n    sbati_max: Optional[float] = None,\n    sterr_min: Optional[float] = None,\n    sterr_max: Optional[float] = None,\n    valeurfonc_min: Optional[float] = None,\n    valeurfonc_max: Optional[float] = None,\n    fields: Optional[str] = None,\n    page: Optional[int] = None,\n    page_size: Optional[int] = 500,\n    paginate: bool = True,\n    format_output: str = \"dataframe\",\n) -&gt; gpd.GeoDataFrame:\n    \"\"\"\n    Retourne, en GeoJSON, les mutations issues de DV3F pour la commune ou l'emprise rectangulaire demand\u00e9e.\n\n    Args:\n        code_insee (str, optionnel): Code INSEE communal ou d'arrondissement municipal (max 10, s\u00e9par\u00e9s par virgule).\n        codes_insee (List[str], optionnel): Liste de codes INSEE.\n        in_bbox (List[float], optionnel): [xmin, ymin, xmax, ymax], max 0.02\u00b0 x 0.02\u00b0.\n        lon_lat (List[float], optionnel): Coordonn\u00e9es [lon, lat].\n        contains_lon_lat (List[float], optionnel): Coordonn\u00e9es \u00e0 contenir [lon, lat].\n        anneemut (str, optionnel): Ann\u00e9e de mutation (&gt;=2010).\n        anneemut_min (str, optionnel): Ann\u00e9e minimale.\n        anneemut_max (str, optionnel): Ann\u00e9e maximale.\n        codtypbien (str, optionnel): Typologie de bien (s\u00e9par\u00e9s par virgule).\n        idnatmut (str, optionnel): Nature de mutation (s\u00e9par\u00e9s par virgule).\n        vefa (str, optionnel): Vente en l'\u00e9tat futur d'ach\u00e8vement.\n        codtypproa (str, optionnel): Typologie acheteur (s\u00e9par\u00e9s par virgule).\n        codtypprov (str, optionnel): Typologie vendeur (s\u00e9par\u00e9s par virgule).\n        filtre (str, optionnel): Code pour exclure des transactions particuli\u00e8res.\n        segmtab (str, optionnel): Note de segment terrain \u00e0 b\u00e2tir.\n        sbati_min (float, optionnel): Surface b\u00e2tie minimale.\n        sbati_max (float, optionnel): Surface b\u00e2tie maximale.\n        sterr_min (float, optionnel): Surface terrain minimale.\n        sterr_max (float, optionnel): Surface terrain maximale.\n        valeurfonc_min (float, optionnel): Valeur fonci\u00e8re minimale (\u20ac).\n        valeurfonc_max (float, optionnel): Valeur fonci\u00e8re maximale (\u20ac).\n        fields (str, optionnel): 'all' pour obtenir tous les champs, None sinon.\n        page (int, optionnel): Page de r\u00e9sultats.\n        page_size (int, optionnel): Nombre de r\u00e9sultats par page.\n        paginate (bool, optionnel): Pagination automatique.\n        format_output (str, optionnel): 'dataframe' ou 'dict'.\n\n    Returns:\n        GeoDataFrame des mutations g\u00e9olocalis\u00e9es.\n    \"\"\"\n    checked_codes_insee, bbox_result, auto_contains_geom = (\n        self._validate_location_params(\n            code_insee=code_insee,\n            codes_insee=codes_insee,\n            coddep=None,\n            in_bbox=in_bbox,\n            lon_lat=lon_lat,\n            contains_lon_lat=contains_lon_lat,\n            max_bbox_size=0.02,\n            max_codes=10,\n        )\n    )\n    params = self._build_params(\n        code_insee=checked_codes_insee,\n        in_bbox=\",\".join(map(str, bbox_result)) if bbox_result else None,\n        contains_geom=auto_contains_geom,\n        anneemut=anneemut,\n        anneemut_min=anneemut_min,\n        anneemut_max=anneemut_max,\n        codtypbien=codtypbien,\n        idnatmut=idnatmut,\n        vefa=vefa,\n        codtypproa=codtypproa,\n        codtypprov=codtypprov,\n        filtre=filtre,\n        segmtab=segmtab,\n        sbati_min=sbati_min,\n        sbati_max=sbati_max,\n        sterr_min=sterr_min,\n        sterr_max=sterr_max,\n        valeurfonc_min=valeurfonc_min,\n        valeurfonc_max=valeurfonc_max,\n        fields=fields,\n        page=page,\n        page_size=page_size,\n    )\n    return self._fetch(\n        endpoint=\"/dv3f/geomutations\",\n        params=params,\n        format_output=format_output,\n        geo=True,\n        paginate=paginate,\n    )\n</code></pre>"},{"location":"endpoints/dv3f/#exemples-dutilisation_1","title":"Exemples d'utilisation","text":"<ul> <li>Mutations DV3F g\u00e9olocalis\u00e9es pour une commune :   <pre><code>client.dv3f.geomutations(code_insee=\"59001\")\n</code></pre></li> <li>Mutations DV3F g\u00e9olocalis\u00e9es dans une emprise :   <pre><code>client.dv3f.geomutations(in_bbox=[2.76, 49.73, 2.779, 49.749])\n</code></pre></li> <li>Mutations DV3F g\u00e9olocalis\u00e9es filtr\u00e9es par type de bien :   <pre><code>client.dv3f.geomutations(code_insee=\"59001\", codtypbien=\"1113\")\n</code></pre></li> </ul>"},{"location":"endpoints/dv3f/#dv3fmutation_by_id","title":"\ud83d\udcc2 <code>dv3f.mutation_by_id</code>","text":""},{"location":"endpoints/dv3f/#description_2","title":"Description","text":"<p>Retourne la mutation DV3F pour l'identifiant fiscal demand\u00e9.</p> <p>Parameters:</p> Name Type Description Default <code>idmutation</code> <code>(int, obligatoire)</code> <p>Identifiant fiscal de la mutation.</p> required <code>format_output</code> <code>(str, optionnel)</code> <p>'dict'.</p> <code>'dict'</code> <p>Returns:</p> Type Description <code>Union[dict, List[dict]]</code> <p>Dictionnaire de la mutation.</p> Source code in <code>apifoncier\\endpoints\\dv3f.py</code> <pre><code>def mutation_by_id(\n    self,\n    idmutation: int,\n    format_output: str = \"dict\",\n) -&gt; Union[dict, List[dict]]:\n    \"\"\"\n    Retourne la mutation DV3F pour l'identifiant fiscal demand\u00e9.\n\n    Args:\n        idmutation (int, obligatoire): Identifiant fiscal de la mutation.\n        format_output (str, optionnel): 'dict'.\n\n    Returns:\n        Dictionnaire de la mutation.\n    \"\"\"\n    if idmutation is None:\n        raise ValidationError(\"idmutation est obligatoire\")\n    return self._fetch(\n        endpoint=f\"/dv3f/mutations/{idmutation}\",\n        params={},\n        format_output=format_output,\n        geo=False,\n        paginate=False,\n    )\n</code></pre>"},{"location":"endpoints/dv3f/#exemples-dutilisation_2","title":"Exemples d'utilisation","text":"<ul> <li>Mutation DV3F par identifiant :   <pre><code>client.dv3f.mutation_by_id(idmutation=123456)\n</code></pre></li> </ul>"},{"location":"endpoints/dvf_opendata/","title":"DVF Open Data - principaux endpoints","text":"<p>Permet d'interroger les mutations DVF+ et leurs g\u00e9om\u00e9tries.</p>"},{"location":"endpoints/dvf_opendata/#dvf_opendatamutations","title":"\ud83d\udcc2 <code>dvf_opendata.mutations</code>","text":""},{"location":"endpoints/dvf_opendata/#description","title":"Description","text":"<p>Retourne les mutations issues de DVF+ pour la commune ou l'emprise rectangulaire demand\u00e9e.</p> <p>Parameters:</p> Name Type Description Default <code>code_insee</code> <code>(str, optionnel)</code> <p>Code INSEE de la commune.</p> <code>None</code> <code>codes_insee</code> <code>(List[str], optionnel)</code> <p>Liste de codes INSEE.</p> <code>None</code> <code>in_bbox</code> <code>(List[float], optionnel)</code> <p>[min_lon, min_lat, max_lon, max_lat].</p> <code>None</code> <code>lon_lat</code> <code>(List[float], optionnel)</code> <p>[longitude, latitude].</p> <code>None</code> <code>contains_lon_lat</code> <code>(List[float], optionnel)</code> <p>[longitude, latitude] pour filtrer par point contenu dans l'emprise.</p> <code>None</code> <code>anneemut</code> <code>(str, optionnel)</code> <p>Ann\u00e9e de la mutation au format YYYY.</p> <code>None</code> <code>anneemut_min</code> <code>(str, optionnel)</code> <p>Ann\u00e9e de mutation minimale au format YYYY.</p> <code>None</code> <code>anneemut_max</code> <code>(str, optionnel)</code> <p>Ann\u00e9e de mutation maximale au format YYYY.</p> <code>None</code> <code>codtypbien</code> <code>(str, optionnel)</code> <p>Code du type de bien.</p> <code>None</code> <code>idnatmut</code> <code>(str, optionnel)</code> <p>Identifiant national de la mutation.</p> <code>None</code> <code>vefa</code> <code>(str, optionnel)</code> <p>Statut VEFA (Vente en l'\u00c9tat Futur d'Ach\u00e8vement).</p> <code>None</code> <code>sbati_min</code> <code>(float, optionnel)</code> <p>Superficie b\u00e2tie minimale.</p> <code>None</code> <code>sbati_max</code> <code>(float, optionnel)</code> <p>Superficie b\u00e2tie maximale.</p> <code>None</code> <code>sterr_min</code> <code>(float, optionnel)</code> <p>Superficie terrain minimale.</p> <code>None</code> <code>sterr_max</code> <code>(float, optionnel)</code> <p>Superficie terrain maximale.</p> <code>None</code> <code>valeurfonc_min</code> <code>(float, optionnel)</code> <p>Valeur fonci\u00e8re minimale.</p> <code>None</code> <code>valeurfonc_max</code> <code>(float, optionnel)</code> <p>Valeur fonci\u00e8re maximale.</p> <code>None</code> <code>fields</code> <code>(str, optionnel)</code> <p>'all' pour obtenir tous les champs, None sinon.</p> <code>None</code> <code>ordering</code> <code>(str, optionnel)</code> <p>Crit\u00e8re de tri des r\u00e9sultats.</p> <code>None</code> <code>page</code> <code>(int, optionnel)</code> <p>Num\u00e9ro de la page pour la pagination.</p> <code>None</code> <code>page_size</code> <code>(int, optionnel)</code> <p>Nombre de r\u00e9sultats par page.</p> <code>500</code> <code>paginate</code> <code>(bool, optionnel)</code> <p>Activer la pagination ou non.</p> <code>True</code> <code>format_output</code> <code>(str, optionnel)</code> <p>Format de sortie ('dataframe' ou 'dict').</p> <code>'dataframe'</code> <p>Returns:</p> Type Description <code>Union[DataFrame, List[dict]]</code> <p>DataFrame ou liste de dictionnaires des mutations.</p> Source code in <code>apifoncier\\endpoints\\dvf_opendata.py</code> <pre><code>def mutations(\n    self,\n    code_insee: Optional[str] = None,\n    codes_insee: Optional[List[str]] = None,\n    in_bbox: Optional[List[float]] = None,\n    lon_lat: Optional[List[float]] = None,\n    contains_lon_lat: Optional[List[float]] = None,\n    anneemut: Optional[str] = None,\n    anneemut_min: Optional[str] = None,\n    anneemut_max: Optional[str] = None,\n    codtypbien: Optional[str] = None,\n    idnatmut: Optional[str] = None,\n    vefa: Optional[str] = None,\n    sbati_min: Optional[float] = None,\n    sbati_max: Optional[float] = None,\n    sterr_min: Optional[float] = None,\n    sterr_max: Optional[float] = None,\n    valeurfonc_min: Optional[float] = None,\n    valeurfonc_max: Optional[float] = None,\n    fields: Optional[str] = None,\n    ordering: Optional[str] = None,\n    page: Optional[int] = None,\n    page_size: Optional[int] = 500,\n    paginate: bool = True,\n    format_output: str = \"dataframe\",\n) -&gt; Union[pd.DataFrame, List[dict]]:\n    \"\"\"\n    Retourne les mutations issues de DVF+ pour la commune ou l'emprise rectangulaire demand\u00e9e.\n\n    Args:\n        code_insee (str, optionnel): Code INSEE de la commune.\n        codes_insee (List[str], optionnel): Liste de codes INSEE.\n        in_bbox (List[float], optionnel): [min_lon, min_lat, max_lon, max_lat].\n        lon_lat (List[float], optionnel): [longitude, latitude].\n        contains_lon_lat (List[float], optionnel): [longitude, latitude] pour filtrer par point contenu dans l'emprise.\n        anneemut (str, optionnel): Ann\u00e9e de la mutation au format YYYY.\n        anneemut_min (str, optionnel): Ann\u00e9e de mutation minimale au format YYYY.\n        anneemut_max (str, optionnel): Ann\u00e9e de mutation maximale au format YYYY.\n        codtypbien (str, optionnel): Code du type de bien.\n        idnatmut (str, optionnel): Identifiant national de la mutation.\n        vefa (str, optionnel): Statut VEFA (Vente en l'\u00c9tat Futur d'Ach\u00e8vement).\n        sbati_min (float, optionnel): Superficie b\u00e2tie minimale.\n        sbati_max (float, optionnel): Superficie b\u00e2tie maximale.\n        sterr_min (float, optionnel): Superficie terrain minimale.\n        sterr_max (float, optionnel): Superficie terrain maximale.\n        valeurfonc_min (float, optionnel): Valeur fonci\u00e8re minimale.\n        valeurfonc_max (float, optionnel): Valeur fonci\u00e8re maximale.\n        fields (str, optionnel): 'all' pour obtenir tous les champs, None sinon.\n        ordering (str, optionnel): Crit\u00e8re de tri des r\u00e9sultats.\n        page (int, optionnel): Num\u00e9ro de la page pour la pagination.\n        page_size (int, optionnel): Nombre de r\u00e9sultats par page.\n        paginate (bool, optionnel): Activer la pagination ou non.\n        format_output (str, optionnel): Format de sortie ('dataframe' ou 'dict').\n\n    Returns:\n        DataFrame ou liste de dictionnaires des mutations.\n    \"\"\"\n\n    # Validation des param\u00e8tres de localisation avec mutualisation\n    checked_codes_insee, bbox_result, auto_contains_geom = (\n        self._validate_location_params(\n            code_insee=code_insee,\n            codes_insee=codes_insee,\n            coddep=None,\n            in_bbox=in_bbox,\n            lon_lat=lon_lat,\n            contains_lon_lat=contains_lon_lat,\n            max_bbox_size=0.02,\n            max_codes=10,\n        )\n    )\n\n    # Construction des param\u00e8tres\n    params = self._build_params(\n        code_insee=checked_codes_insee,\n        in_bbox=\",\".join(map(str, bbox_result)) if bbox_result else None,\n        anneemut=anneemut,\n        anneemut_min=anneemut_min,\n        anneemut_max=anneemut_max,\n        contains_geom=auto_contains_geom,\n        codtypbien=codtypbien,\n        idnatmut=idnatmut,\n        vefa=vefa,\n        sbati_min=sbati_min,\n        sbati_max=sbati_max,\n        sterr_min=sterr_min,\n        sterr_max=sterr_max,\n        valeurfonc_min=valeurfonc_min,\n        valeurfonc_max=valeurfonc_max,\n        fields=fields,\n        ordering=ordering,\n        page=page,\n        page_size=page_size,\n    )\n\n    return self._fetch(\n        endpoint=\"/dvf_opendata/mutations\",\n        params=params,\n        format_output=format_output,\n        geo=False,\n        paginate=paginate,\n    )\n</code></pre>"},{"location":"endpoints/dvf_opendata/#exemple-dutilisation","title":"Exemple d'utilisation","text":"<ul> <li>Interroger les mutations DVF+ pour une commune donn\u00e9e (ici, via le code INSEE 59001) :</li> </ul> <pre><code>from apifoncier import ApiFoncierClient\n\nclient = ApiFoncierClient()\nmutations = client.dvf_opendata.mutations(code_insee=\"59001\")\n</code></pre> <ul> <li>Interroger les mutations DVF+ dans une emprise geographique (ici, un rectangle d\u00e9fini par ses coordonn\u00e9es) :</li> </ul> <pre><code>client = ApiFoncierClient()\nmutations = client.dvf_opendata.mutations(in_bbox=[2.76, 49.73, 2.779, 49.749])\n</code></pre> <ul> <li>Interroger les mutations DVF+ pour une commune donn\u00e9e (ici, via le code INSEE 59350) en 2022, pour des biens de type maison (codtypbien=111) et dont la surface est comprise entre 1000 et 5000 m2, en r\u00e9cup\u00e9rant tous les champs disponibles :</li> </ul> <pre><code>client.dvf_opendata.mutations(\n    code_insee=\"59350\",\n    anneemut=\"2022\",\n    fields=\"all\",\n    sterr_min=1000,\n    sterr_max=5000,\n    codtypbien=\"111\",\n)\n</code></pre>"},{"location":"endpoints/dvf_opendata/#dvf_opendatageomutations","title":"\ud83d\udcc2 <code>dvf_opendata.geomutations</code>","text":""},{"location":"endpoints/dvf_opendata/#description_1","title":"Description","text":"<p>Retourne, en GeoJSON, les mutations issues de DVF+ pour la commune ou l'emprise rectangulaire demand\u00e9e.</p> <p>Parameters:</p> Name Type Description Default <code>code_insee</code> <code>(str, optionnel)</code> <p>Code INSEE de la commune.</p> <code>None</code> <code>codes_insee</code> <code>(List[str], optionnel)</code> <p>Liste de codes INSEE.</p> <code>None</code> <code>in_bbox</code> <code>(List[float], optionnel)</code> <p>[min_lon, min_lat, max_lon, max_lat].</p> <code>None</code> <code>lon_lat</code> <code>(List[float], optionnel)</code> <p>[longitude, latitude].</p> <code>None</code> <code>contains_lon_lat</code> <code>(List[float], optionnel)</code> <p>[longitude, latitude] pour filtrer par point contenu dans l'emprise.</p> <code>None</code> <code>anneemut</code> <code>(str, optionnel)</code> <p>Ann\u00e9e de la mutation au format YYYY.</p> <code>None</code> <code>anneemut_min</code> <code>(str, optionnel)</code> <p>Ann\u00e9e de mutation minimale au format YYYY.</p> <code>None</code> <code>anneemut_max</code> <code>(str, optionnel)</code> <p>Ann\u00e9e de mutation maximale au format YYYY.</p> <code>None</code> <code>codtypbien</code> <code>(str, optionnel)</code> <p>Code du type de bien.</p> <code>None</code> <code>idnatmut</code> <code>(str, optionnel)</code> <p>Identifiant national de la mutation.</p> <code>None</code> <code>vefa</code> <code>(str, optionnel)</code> <p>Statut VEFA (Vente en l'\u00c9tat Futur d'Ach\u00e8vement).</p> <code>None</code> <code>sbati_min</code> <code>(float, optionnel)</code> <p>Superficie b\u00e2tie minimale.</p> <code>None</code> <code>sbati_max</code> <code>(float, optionnel)</code> <p>Superficie b\u00e2tie maximale.</p> <code>None</code> <code>sterr_min</code> <code>(float, optionnel)</code> <p>Superficie terrain minimale.</p> <code>None</code> <code>sterr_max</code> <code>(float, optionnel)</code> <p>Superficie terrain maximale.</p> <code>None</code> <code>valeurfonc_min</code> <code>(float, optionnel)</code> <p>Valeur fonci\u00e8re minimale.</p> <code>None</code> <code>valeurfonc_max</code> <code>(float, optionnel)</code> <p>Valeur fonci\u00e8re maximale.</p> <code>None</code> <code>fields</code> <code>(str, optionnel)</code> <p>'all' pour obtenir tous les champs, None sinon.</p> <code>None</code> <code>ordering</code> <code>(str, optionnel)</code> <p>Crit\u00e8re de tri des r\u00e9sultats.</p> <code>None</code> <code>page</code> <code>(int, optionnel)</code> <p>Num\u00e9ro de la page pour la pagination.</p> <code>None</code> <code>page_size</code> <code>(int, optionnel)</code> <p>Nombre de r\u00e9sultats par page.</p> <code>500</code> <code>paginate</code> <code>(bool, optionnel)</code> <p>Activer la pagination ou non.</p> <code>True</code> <code>format_output</code> <code>(str, optionnel)</code> <p>Format de sortie ('dataframe' ou 'dict').</p> <code>'dataframe'</code> <p>Returns:</p> Type Description <code>Union[GeoDataFrame, List[dict]]</code> <p>GeoDataFrame ou liste de dictionnaires des mutations g\u00e9olocalis\u00e9es.</p> Source code in <code>apifoncier\\endpoints\\dvf_opendata.py</code> <pre><code>def geomutations(\n    self,\n    code_insee: Optional[str] = None,\n    codes_insee: Optional[List[str]] = None,\n    in_bbox: Optional[List[float]] = None,\n    lon_lat: Optional[List[float]] = None,\n    contains_lon_lat: Optional[List[float]] = None,\n    anneemut: Optional[str] = None,\n    anneemut_min: Optional[str] = None,\n    anneemut_max: Optional[str] = None,\n    codtypbien: Optional[str] = None,\n    idnatmut: Optional[str] = None,\n    vefa: Optional[str] = None,\n    sbati_min: Optional[float] = None,\n    sbati_max: Optional[float] = None,\n    sterr_min: Optional[float] = None,\n    sterr_max: Optional[float] = None,\n    valeurfonc_min: Optional[float] = None,\n    valeurfonc_max: Optional[float] = None,\n    fields: Optional[str] = None,\n    ordering: Optional[str] = None,\n    page: Optional[int] = None,\n    page_size: Optional[int] = 500,\n    paginate: bool = True,\n    format_output: str = \"dataframe\",\n) -&gt; Union[gpd.GeoDataFrame, List[dict]]:\n    \"\"\"\n    Retourne, en GeoJSON, les mutations issues de DVF+ pour la commune ou l'emprise rectangulaire demand\u00e9e.\n\n    Args:\n        code_insee (str, optionnel): Code INSEE de la commune.\n        codes_insee (List[str], optionnel): Liste de codes INSEE.\n        in_bbox (List[float], optionnel): [min_lon, min_lat, max_lon, max_lat].\n        lon_lat (List[float], optionnel): [longitude, latitude].\n        contains_lon_lat (List[float], optionnel): [longitude, latitude] pour filtrer par point contenu dans l'emprise.\n        anneemut (str, optionnel): Ann\u00e9e de la mutation au format YYYY.\n        anneemut_min (str, optionnel): Ann\u00e9e de mutation minimale au format YYYY.\n        anneemut_max (str, optionnel): Ann\u00e9e de mutation maximale au format YYYY.\n        codtypbien (str, optionnel): Code du type de bien.\n        idnatmut (str, optionnel): Identifiant national de la mutation.\n        vefa (str, optionnel): Statut VEFA (Vente en l'\u00c9tat Futur d'Ach\u00e8vement).\n        sbati_min (float, optionnel): Superficie b\u00e2tie minimale.\n        sbati_max (float, optionnel): Superficie b\u00e2tie maximale.\n        sterr_min (float, optionnel): Superficie terrain minimale.\n        sterr_max (float, optionnel): Superficie terrain maximale.\n        valeurfonc_min (float, optionnel): Valeur fonci\u00e8re minimale.\n        valeurfonc_max (float, optionnel): Valeur fonci\u00e8re maximale.\n        fields (str, optionnel): 'all' pour obtenir tous les champs, None sinon.\n        ordering (str, optionnel): Crit\u00e8re de tri des r\u00e9sultats.\n        page (int, optionnel): Num\u00e9ro de la page pour la pagination.\n        page_size (int, optionnel): Nombre de r\u00e9sultats par page.\n        paginate (bool, optionnel): Activer la pagination ou non.\n        format_output (str, optionnel): Format de sortie ('dataframe' ou 'dict').\n\n    Returns:\n        GeoDataFrame ou liste de dictionnaires des mutations g\u00e9olocalis\u00e9es.\n    \"\"\"\n\n    # Validation des param\u00e8tres de localisation avec mutualisation\n    checked_codes_insee, bbox_result, auto_contains_geom = (\n        self._validate_location_params(\n            code_insee=code_insee,\n            codes_insee=codes_insee,\n            coddep=None,\n            in_bbox=in_bbox,\n            lon_lat=lon_lat,\n            contains_lon_lat=contains_lon_lat,\n            max_bbox_size=0.02,\n            max_codes=10,\n        )\n    )\n\n    # Construction des param\u00e8tres\n    params = self._build_params(\n        code_insee=checked_codes_insee,\n        in_bbox=\",\".join(map(str, bbox_result)) if bbox_result else None,\n        anneemut=anneemut,\n        anneemut_min=anneemut_min,\n        anneemut_max=anneemut_max,\n        contains_geom=auto_contains_geom,\n        codtypbien=codtypbien,\n        idnatmut=idnatmut,\n        vefa=vefa,\n        sbati_min=sbati_min,\n        sbati_max=sbati_max,\n        sterr_min=sterr_min,\n        sterr_max=sterr_max,\n        valeurfonc_min=valeurfonc_min,\n        valeurfonc_max=valeurfonc_max,\n        fields=fields,\n        ordering=ordering,\n        page=page,\n        page_size=page_size,\n    )\n\n    return self._fetch(\n        endpoint=\"/dvf_opendata/geomutations\",\n        params=params,\n        format_output=format_output,\n        geo=True,\n        paginate=paginate,\n    )\n</code></pre>"},{"location":"endpoints/dvf_opendata/#exemple-dutilisation_1","title":"Exemple d'utilisation","text":"<ul> <li>Interroger, sous forme d'un geodataframe, les mutations DVF+ pour une commune donn\u00e9e (ici, via le code INSEE 59001) :</li> </ul> <pre><code>from apifoncier import ApiFoncierClient\n\nclient = ApiFoncierClient()\nclient.dvf_opendata.geomutations(code_insee=\"59001\")\n</code></pre> <ul> <li>Interroger, sous forme d'un geodataframe, les mutations DVF+ pour plusieurs communes (ici, via les codes INSEE 59350 et 59009), en 2023, pour des biens de type appartement (codtypbien=121) et dont la surface b\u00e2tie est sup\u00e9rieure \u00e0 100 m2 :</li> </ul> <pre><code>client.dvf_opendata.geomutations(\n    codes_insee=[\"59350\", \"59009\"],\n    sbati_min=100,\n    anneemut=2023,\n    codtypbien=\"121\",\n)\n</code></pre>"},{"location":"endpoints/ff/","title":"Fichiers Fonciers - principaux endpoints","text":"<p>Permet d'interroger les parcelles, locaux, TUPs, droits de propri\u00e9t\u00e9 et leurs g\u00e9om\u00e9tries.</p>"},{"location":"endpoints/ff/#clef-api","title":"Clef API","text":"<p>Une cl\u00e9 API est requise pour acc\u00e9der aux endpoints FF. Vous pouvez obtenir une cl\u00e9 via le Portail Donn\u00e9es fonci\u00e8res.</p> <pre><code>from apifoncier.client import ApiFoncierClient\n\napi_key = \"VOTRE_CLE_API\"  # Cl\u00e9 API requise pour acc\u00e9der aux endpoints FF\nclient = ApiFoncierClient({\"api_key\": api_key})\n</code></pre>"},{"location":"endpoints/ff/#ffparcelles","title":"\ud83d\udcc2 <code>ff.parcelles</code>","text":""},{"location":"endpoints/ff/#description","title":"Description","text":"<p>Retourne les parcelles issues des Fichiers Fonciers pour la commune ou l'emprise rectangulaire demand\u00e9e.</p> <p>Parameters:</p> Name Type Description Default <code>code_insee</code> <code>(str, optionnel)</code> <p>Code INSEE communal ou d'arrondissement municipal (max 10, s\u00e9par\u00e9s par virgule).</p> <code>None</code> <code>codes_insee</code> <code>(List[str], optionnel)</code> <p>Liste de codes INSEE.</p> <code>None</code> <code>in_bbox</code> <code>(List[float], optionnel)</code> <p>[xmin, ymin, xmax, ymax], max 0.02\u00b0 x 0.02\u00b0.</p> <code>None</code> <code>lon_lat</code> <code>(List[float], optionnel)</code> <p>Coordonn\u00e9es [lon, lat].</p> <code>None</code> <code>contains_lon_lat</code> <code>(List[float], optionnel)</code> <p>Coordonn\u00e9es \u00e0 contenir [lon, lat].</p> <code>None</code> <code>catpro3</code> <code>(str, optionnel)</code> <p>Cat\u00e9gorie propri\u00e9taire.</p> <code>None</code> <code>ctpdl</code> <code>(str, optionnel)</code> <p>Type de pdl (copropri\u00e9t\u00e9).</p> <code>None</code> <code>dcntarti_min</code> <code>(int, optionnel)</code> <p>Surface artificialis\u00e9e minimale (m2).</p> <code>None</code> <code>dcntarti_max</code> <code>(int, optionnel)</code> <p>Surface artificialis\u00e9e maximale (m2).</p> <code>None</code> <code>dcntnaf_min</code> <code>(float, optionnel)</code> <p>Surface NAF minimale (m2).</p> <code>None</code> <code>dcntnaf_max</code> <code>(float, optionnel)</code> <p>Surface NAF maximale (m2).</p> <code>None</code> <code>dcntpa_min</code> <code>(int, optionnel)</code> <p>Surface parcelle minimale (m2).</p> <code>None</code> <code>dcntpa_max</code> <code>(int, optionnel)</code> <p>Surface parcelle maximale (m2).</p> <code>None</code> <code>idcomtxt</code> <code>(str, optionnel)</code> <p>Libell\u00e9 commune (recherche texte).</p> <code>None</code> <code>idpar</code> <code>(List[str], optionnel)</code> <p>Identifiants de parcelle (max 10, s\u00e9par\u00e9s par virgule).</p> <code>None</code> <code>jannatmin_min</code> <code>(int, optionnel)</code> <p>Ann\u00e9e construction minimale.</p> <code>None</code> <code>jannatmin_max</code> <code>(int, optionnel)</code> <p>Ann\u00e9e construction maximale.</p> <code>None</code> <code>nlocal_min</code> <code>(int, optionnel)</code> <p>Nombre de locaux minimal.</p> <code>None</code> <code>nlocal_max</code> <code>(int, optionnel)</code> <p>Nombre de locaux maximal.</p> <code>None</code> <code>nlogh_min</code> <code>(int, optionnel)</code> <p>Nombre de logements minimal.</p> <code>None</code> <code>nlogh_max</code> <code>(int, optionnel)</code> <p>Nombre de logements maximal.</p> <code>None</code> <code>slocal_min</code> <code>(int, optionnel)</code> <p>Surface parties d'\u00e9valuation minimale (m2).</p> <code>None</code> <code>slocal_max</code> <code>(int, optionnel)</code> <p>Surface parties d'\u00e9valuation maximale (m2).</p> <code>None</code> <code>sprincp_min</code> <code>(int, optionnel)</code> <p>Surface pi\u00e8ces principales pro minimale (m2).</p> <code>None</code> <code>sprincp_max</code> <code>(int, optionnel)</code> <p>Surface pi\u00e8ces principales pro maximale (m2).</p> <code>None</code> <code>stoth_min</code> <code>(int, optionnel)</code> <p>Surface pi\u00e8ces d'habitation minimale (m2).</p> <code>None</code> <code>stoth_max</code> <code>(int, optionnel)</code> <p>Surface pi\u00e8ces d'habitation maximale (m2).</p> <code>None</code> <code>fields</code> <code>(str, optionnel)</code> <p>'all' pour obtenir tous les champs, None sinon.</p> <code>None</code> <code>ordering</code> <code>(str, optionnel)</code> <p>Champ de tri.</p> <code>None</code> <code>page</code> <code>(int, optionnel)</code> <p>Page de r\u00e9sultats.</p> <code>None</code> <code>page_size</code> <code>(int, optionnel)</code> <p>Nombre de r\u00e9sultats par page.</p> <code>500</code> <code>paginate</code> <code>(bool, optionnel)</code> <p>Pagination automatique.</p> <code>True</code> <code>format_output</code> <code>(str, optionnel)</code> <p>'dataframe' ou 'dict'.</p> <code>'dataframe'</code> <p>Returns:</p> Type Description <code>Union[DataFrame, List[dict]]</code> <p>DataFrame ou liste de dictionnaires des parcelles.</p> Source code in <code>apifoncier\\endpoints\\ff.py</code> <pre><code>def parcelles(\n    self,\n    code_insee: Optional[str] = None,\n    codes_insee: Optional[List[str]] = None,\n    in_bbox: Optional[List[float]] = None,\n    lon_lat: Optional[List[float]] = None,\n    contains_lon_lat: Optional[List[float]] = None,\n    catpro3: Optional[str] = None,\n    ctpdl: Optional[str] = None,\n    dcntarti_min: Optional[int] = None,\n    dcntarti_max: Optional[int] = None,\n    dcntnaf_min: Optional[float] = None,\n    dcntnaf_max: Optional[float] = None,\n    dcntpa_min: Optional[int] = None,\n    dcntpa_max: Optional[int] = None,\n    idcomtxt: Optional[str] = None,\n    idpar: Optional[List[str]] = None,\n    jannatmin_min: Optional[int] = None,\n    jannatmin_max: Optional[int] = None,\n    nlocal_min: Optional[int] = None,\n    nlocal_max: Optional[int] = None,\n    nlogh_min: Optional[int] = None,\n    nlogh_max: Optional[int] = None,\n    slocal_min: Optional[int] = None,\n    slocal_max: Optional[int] = None,\n    sprincp_min: Optional[int] = None,\n    sprincp_max: Optional[int] = None,\n    stoth_min: Optional[int] = None,\n    stoth_max: Optional[int] = None,\n    fields: Optional[str] = None,\n    ordering: Optional[str] = None,\n    page: Optional[int] = None,\n    page_size: Optional[int] = 500,\n    paginate: bool = True,\n    format_output: str = \"dataframe\",\n) -&gt; Union[pd.DataFrame, List[dict]]:\n    \"\"\"\n    Retourne les parcelles issues des Fichiers Fonciers pour la commune ou l'emprise rectangulaire demand\u00e9e.\n\n    Args:\n        code_insee (str, optionnel): Code INSEE communal ou d'arrondissement municipal (max 10, s\u00e9par\u00e9s par virgule).\n        codes_insee (List[str], optionnel): Liste de codes INSEE.\n        in_bbox (List[float], optionnel): [xmin, ymin, xmax, ymax], max 0.02\u00b0 x 0.02\u00b0.\n        lon_lat (List[float], optionnel): Coordonn\u00e9es [lon, lat].\n        contains_lon_lat (List[float], optionnel): Coordonn\u00e9es \u00e0 contenir [lon, lat].\n        catpro3 (str, optionnel): Cat\u00e9gorie propri\u00e9taire.\n        ctpdl (str, optionnel): Type de pdl (copropri\u00e9t\u00e9).\n        dcntarti_min (int, optionnel): Surface artificialis\u00e9e minimale (m2).\n        dcntarti_max (int, optionnel): Surface artificialis\u00e9e maximale (m2).\n        dcntnaf_min (float, optionnel): Surface NAF minimale (m2).\n        dcntnaf_max (float, optionnel): Surface NAF maximale (m2).\n        dcntpa_min (int, optionnel): Surface parcelle minimale (m2).\n        dcntpa_max (int, optionnel): Surface parcelle maximale (m2).\n        idcomtxt (str, optionnel): Libell\u00e9 commune (recherche texte).\n        idpar (List[str], optionnel): Identifiants de parcelle (max 10, s\u00e9par\u00e9s par virgule).\n        jannatmin_min (int, optionnel): Ann\u00e9e construction minimale.\n        jannatmin_max (int, optionnel): Ann\u00e9e construction maximale.\n        nlocal_min (int, optionnel): Nombre de locaux minimal.\n        nlocal_max (int, optionnel): Nombre de locaux maximal.\n        nlogh_min (int, optionnel): Nombre de logements minimal.\n        nlogh_max (int, optionnel): Nombre de logements maximal.\n        slocal_min (int, optionnel): Surface parties d'\u00e9valuation minimale (m2).\n        slocal_max (int, optionnel): Surface parties d'\u00e9valuation maximale (m2).\n        sprincp_min (int, optionnel): Surface pi\u00e8ces principales pro minimale (m2).\n        sprincp_max (int, optionnel): Surface pi\u00e8ces principales pro maximale (m2).\n        stoth_min (int, optionnel): Surface pi\u00e8ces d'habitation minimale (m2).\n        stoth_max (int, optionnel): Surface pi\u00e8ces d'habitation maximale (m2).\n        fields (str, optionnel): 'all' pour obtenir tous les champs, None sinon.\n        ordering (str, optionnel): Champ de tri.\n        page (int, optionnel): Page de r\u00e9sultats.\n        page_size (int, optionnel): Nombre de r\u00e9sultats par page.\n        paginate (bool, optionnel): Pagination automatique.\n        format_output (str, optionnel): 'dataframe' ou 'dict'.\n\n    Returns:\n        DataFrame ou liste de dictionnaires des parcelles.\n    \"\"\"\n    # Validation des param\u00e8tres de localisation - emprise max 0.02\u00b0 pour FF\n    checked_codes_insee, bbox_result, auto_contains_geom = (\n        self._validate_location_params(\n            code_insee=code_insee,\n            codes_insee=codes_insee,\n            coddep=None,\n            in_bbox=in_bbox,\n            lon_lat=lon_lat,\n            contains_lon_lat=contains_lon_lat,\n            max_bbox_size=0.02,  # Contrainte FF: 0.02\u00b0 max\n            max_codes=10,\n        )\n    )\n\n    # Construction des param\u00e8tres\n    params = self._build_params(\n        code_insee=checked_codes_insee,\n        in_bbox=\",\".join(map(str, bbox_result)) if bbox_result else None,\n        contains_geom=auto_contains_geom,\n        catpro3=catpro3,\n        ctpdl=ctpdl,\n        dcntarti_min=dcntarti_min,\n        dcntarti_max=dcntarti_max,\n        dcntnaf_min=dcntnaf_min,\n        dcntnaf_max=dcntnaf_max,\n        dcntpa_min=dcntpa_min,\n        dcntpa_max=dcntpa_max,\n        idcomtxt=idcomtxt,\n        idpar=\",\".join(idpar) if idpar else None,\n        jannatmin_min=jannatmin_min,\n        jannatmin_max=jannatmin_max,\n        nlocal_min=nlocal_min,\n        nlocal_max=nlocal_max,\n        nlogh_min=nlogh_min,\n        nlogh_max=nlogh_max,\n        slocal_min=slocal_min,\n        slocal_max=slocal_max,\n        sprincp_min=sprincp_min,\n        sprincp_max=sprincp_max,\n        stoth_min=stoth_min,\n        stoth_max=stoth_max,\n        fields=fields,\n        ordering=ordering,\n        page=page,\n        page_size=page_size,\n    )\n\n    return self._fetch(\n        endpoint=\"/ff/parcelles\",\n        params=params,\n        format_output=format_output,\n        geo=False,\n        paginate=paginate,\n    )\n</code></pre>"},{"location":"endpoints/ff/#exemples-dutilisation","title":"Exemples d'utilisation","text":"<ul> <li>Parcelles d'une commune : <pre><code>client.ff.parcelles(code_insee=\"59001\")\n</code></pre></li> <li>Parcelles dans une emprise g\u00e9ographique : <pre><code>client.ff.parcelles(in_bbox=[2.76, 49.73, 2.779, 49.749])\n</code></pre></li> <li>Parcelles avec plusieurs codes INSEE et une surface minimale de 1000 m\u00b2 : <pre><code>client.ff.parcelles(codes_insee=[\"59001\", \"59002\"], dcntpa_min=1000)\n</code></pre></li> <li> <p>Parcelles avec filtre centr\u00e9e sur une coordonn\u00e9e (lon, lat) : <pre><code>client.ff.parcelles(lon_lat=[2.76, 49.73])\n</code></pre></p> </li> <li> <p>Parcelles appartenant \u00e0 des propri\u00e9taires personnes physiques (catpro3=\"X\"), avec au moins un local (nlocal_min=1) et construites apr\u00e8s 2010 (jannatmin_min=2010) dans la commune dont le code insee est 59001 : <pre><code>client.ff.parcelles(code_insee=\"59001\", catpro3=\"X\", nlocal_min=1, jannatmin_min=2010)\n</code></pre></p> </li> </ul>"},{"location":"endpoints/ff/#ffparcelle_by_id","title":"\ud83d\udcc2 <code>ff.parcelle_by_id</code>","text":""},{"location":"endpoints/ff/#description_1","title":"Description","text":"<p>Retourne la parcelle des Fichiers fonciers pour l'identifiant idparcelle demand\u00e9.</p> <p>Parameters:</p> Name Type Description Default <code>idparcelle</code> <code>(str, obligatoire)</code> <p>Identifiant de la parcelle.</p> required <code>format_output</code> <code>(str, optionnel)</code> <p>'dict'.</p> <code>'dict'</code> <p>Returns:</p> Type Description <code>Union[dict, List[dict]]</code> <p>Dictionnaire de la parcelle.</p> Source code in <code>apifoncier\\endpoints\\ff.py</code> <pre><code>def parcelle_by_id(\n    self,\n    idparcelle: str,\n    format_output: str = \"dict\",\n) -&gt; Union[dict, List[dict]]:\n    \"\"\"\n    Retourne la parcelle des Fichiers fonciers pour l'identifiant idparcelle demand\u00e9.\n\n    Args:\n        idparcelle (str, obligatoire): Identifiant de la parcelle.\n        format_output (str, optionnel): 'dict'.\n\n    Returns:\n        Dictionnaire de la parcelle.\n    \"\"\"\n    if not idparcelle:\n        raise ValidationError(\"idparcelle est obligatoire\")\n    return self._fetch(\n        endpoint=f\"/ff/parcelles/{idparcelle}\",\n        params={},\n        format_output=format_output,\n        geo=False,\n        paginate=False,\n    )\n</code></pre>"},{"location":"endpoints/ff/#exemples-dutilisation_1","title":"Exemples d'utilisation","text":"<ul> <li>Parcelle par identifiant : <pre><code>client.ff.parcelle_by_id(\"590010000U1186\")\n</code></pre></li> </ul>"},{"location":"endpoints/ff/#ffgeoparcelles","title":"\ud83d\udcc2 <code>ff.geoparcelles</code>","text":""},{"location":"endpoints/ff/#description_2","title":"Description","text":"<p>Retourne, en GeoJSON, les parcelles issues des Fichiers Fonciers pour la commune ou l'emprise rectangulaire demand\u00e9e.</p> <p>Parameters:</p> Name Type Description Default <code>code_insee</code> <code>(str, optionnel)</code> <p>Code INSEE communal ou d'arrondissement municipal (max 10, s\u00e9par\u00e9s par virgule).</p> <code>None</code> <code>codes_insee</code> <code>(List[str], optionnel)</code> <p>Liste de codes INSEE.</p> <code>None</code> <code>in_bbox</code> <code>(List[float], optionnel)</code> <p>[xmin, ymin, xmax, ymax], max 0.02\u00b0 x 0.02\u00b0.</p> <code>None</code> <code>lon_lat</code> <code>(List[float], optionnel)</code> <p>Coordonn\u00e9es [lon, lat].</p> <code>None</code> <code>contains_lon_lat</code> <code>(List[float], optionnel)</code> <p>Coordonn\u00e9es \u00e0 contenir [lon, lat].</p> <code>None</code> <code>catpro3</code> <code>(str, optionnel)</code> <p>Cat\u00e9gorie propri\u00e9taire.</p> <code>None</code> <code>ctpdl</code> <code>(str, optionnel)</code> <p>Type de pdl (copropri\u00e9t\u00e9).</p> <code>None</code> <code>dcntarti_min</code> <code>(int, optionnel)</code> <p>Surface artificialis\u00e9e minimale (m2).</p> <code>None</code> <code>dcntarti_max</code> <code>(int, optionnel)</code> <p>Surface artificialis\u00e9e maximale (m2).</p> <code>None</code> <code>dcntnaf_min</code> <code>(float, optionnel)</code> <p>Surface NAF minimale (m2).</p> <code>None</code> <code>dcntnaf_max</code> <code>(float, optionnel)</code> <p>Surface NAF maximale (m2).</p> <code>None</code> <code>dcntpa_min</code> <code>(int, optionnel)</code> <p>Surface parcelle minimale (m2).</p> <code>None</code> <code>dcntpa_max</code> <code>(int, optionnel)</code> <p>Surface parcelle maximale (m2).</p> <code>None</code> <code>idcomtxt</code> <code>(str, optionnel)</code> <p>Libell\u00e9 commune (recherche texte).</p> <code>None</code> <code>idpar</code> <code>(List[str], optionnel)</code> <p>Identifiants de parcelle (max 10, s\u00e9par\u00e9s par virgule).</p> <code>None</code> <code>jannatmin_min</code> <code>(int, optionnel)</code> <p>Ann\u00e9e construction minimale.</p> <code>None</code> <code>jannatmin_max</code> <code>(int, optionnel)</code> <p>Ann\u00e9e construction maximale.</p> <code>None</code> <code>nlocal_min</code> <code>(int, optionnel)</code> <p>Nombre de locaux minimal.</p> <code>None</code> <code>nlocal_max</code> <code>(int, optionnel)</code> <p>Nombre de locaux maximal.</p> <code>None</code> <code>nlogh_min</code> <code>(int, optionnel)</code> <p>Nombre de logements minimal.</p> <code>None</code> <code>nlogh_max</code> <code>(int, optionnel)</code> <p>Nombre de logements maximal.</p> <code>None</code> <code>slocal_min</code> <code>(int, optionnel)</code> <p>Surface parties d'\u00e9valuation minimale (m2).</p> <code>None</code> <code>slocal_max</code> <code>(int, optionnel)</code> <p>Surface parties d'\u00e9valuation maximale (m2).</p> <code>None</code> <code>sprincp_min</code> <code>(int, optionnel)</code> <p>Surface pi\u00e8ces principales pro minimale (m2).</p> <code>None</code> <code>sprincp_max</code> <code>(int, optionnel)</code> <p>Surface pi\u00e8ces principales pro maximale (m2).</p> <code>None</code> <code>stoth_min</code> <code>(int, optionnel)</code> <p>Surface pi\u00e8ces d'habitation minimale (m2).</p> <code>None</code> <code>stoth_max</code> <code>(int, optionnel)</code> <p>Surface pi\u00e8ces d'habitation maximale (m2).</p> <code>None</code> <code>fields</code> <code>(str, optionnel)</code> <p>'all' pour obtenir tous les champs, None sinon.</p> <code>None</code> <code>page</code> <code>(int, optionnel)</code> <p>Page de r\u00e9sultats.</p> <code>None</code> <code>page_size</code> <code>(int, optionnel)</code> <p>Nombre de r\u00e9sultats par page.</p> <code>500</code> <code>paginate</code> <code>(bool, optionnel)</code> <p>Pagination automatique.</p> <code>True</code> <code>format_output</code> <code>(str, optionnel)</code> <p>'dataframe' ou 'dict'.</p> <code>'dataframe'</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>GeoDataFrame des parcelles g\u00e9olocalis\u00e9es.</p> Source code in <code>apifoncier\\endpoints\\ff.py</code> <pre><code>def geoparcelles(\n    self,\n    code_insee: Optional[str] = None,\n    codes_insee: Optional[List[str]] = None,\n    in_bbox: Optional[List[float]] = None,\n    lon_lat: Optional[List[float]] = None,\n    contains_lon_lat: Optional[List[float]] = None,\n    catpro3: Optional[str] = None,\n    ctpdl: Optional[str] = None,\n    dcntarti_min: Optional[int] = None,\n    dcntarti_max: Optional[int] = None,\n    dcntnaf_min: Optional[float] = None,\n    dcntnaf_max: Optional[float] = None,\n    dcntpa_min: Optional[int] = None,\n    dcntpa_max: Optional[int] = None,\n    idcomtxt: Optional[str] = None,\n    idpar: Optional[List[str]] = None,\n    jannatmin_min: Optional[int] = None,\n    jannatmin_max: Optional[int] = None,\n    nlocal_min: Optional[int] = None,\n    nlocal_max: Optional[int] = None,\n    nlogh_min: Optional[int] = None,\n    nlogh_max: Optional[int] = None,\n    slocal_min: Optional[int] = None,\n    slocal_max: Optional[int] = None,\n    sprincp_min: Optional[int] = None,\n    sprincp_max: Optional[int] = None,\n    stoth_min: Optional[int] = None,\n    stoth_max: Optional[int] = None,\n    fields: Optional[str] = None,\n    page: Optional[int] = None,\n    page_size: Optional[int] = 500,\n    paginate: bool = True,\n    format_output: str = \"dataframe\",\n) -&gt; gpd.GeoDataFrame:\n    \"\"\"\n    Retourne, en GeoJSON, les parcelles issues des Fichiers Fonciers pour la commune ou l'emprise rectangulaire demand\u00e9e.\n\n    Args:\n        code_insee (str, optionnel): Code INSEE communal ou d'arrondissement municipal (max 10, s\u00e9par\u00e9s par virgule).\n        codes_insee (List[str], optionnel): Liste de codes INSEE.\n        in_bbox (List[float], optionnel): [xmin, ymin, xmax, ymax], max 0.02\u00b0 x 0.02\u00b0.\n        lon_lat (List[float], optionnel): Coordonn\u00e9es [lon, lat].\n        contains_lon_lat (List[float], optionnel): Coordonn\u00e9es \u00e0 contenir [lon, lat].\n        catpro3 (str, optionnel): Cat\u00e9gorie propri\u00e9taire.\n        ctpdl (str, optionnel): Type de pdl (copropri\u00e9t\u00e9).\n        dcntarti_min (int, optionnel): Surface artificialis\u00e9e minimale (m2).\n        dcntarti_max (int, optionnel): Surface artificialis\u00e9e maximale (m2).\n        dcntnaf_min (float, optionnel): Surface NAF minimale (m2).\n        dcntnaf_max (float, optionnel): Surface NAF maximale (m2).\n        dcntpa_min (int, optionnel): Surface parcelle minimale (m2).\n        dcntpa_max (int, optionnel): Surface parcelle maximale (m2).\n        idcomtxt (str, optionnel): Libell\u00e9 commune (recherche texte).\n        idpar (List[str], optionnel): Identifiants de parcelle (max 10, s\u00e9par\u00e9s par virgule).\n        jannatmin_min (int, optionnel): Ann\u00e9e construction minimale.\n        jannatmin_max (int, optionnel): Ann\u00e9e construction maximale.\n        nlocal_min (int, optionnel): Nombre de locaux minimal.\n        nlocal_max (int, optionnel): Nombre de locaux maximal.\n        nlogh_min (int, optionnel): Nombre de logements minimal.\n        nlogh_max (int, optionnel): Nombre de logements maximal.\n        slocal_min (int, optionnel): Surface parties d'\u00e9valuation minimale (m2).\n        slocal_max (int, optionnel): Surface parties d'\u00e9valuation maximale (m2).\n        sprincp_min (int, optionnel): Surface pi\u00e8ces principales pro minimale (m2).\n        sprincp_max (int, optionnel): Surface pi\u00e8ces principales pro maximale (m2).\n        stoth_min (int, optionnel): Surface pi\u00e8ces d'habitation minimale (m2).\n        stoth_max (int, optionnel): Surface pi\u00e8ces d'habitation maximale (m2).\n        fields (str, optionnel): 'all' pour obtenir tous les champs, None sinon.\n        page (int, optionnel): Page de r\u00e9sultats.\n        page_size (int, optionnel): Nombre de r\u00e9sultats par page.\n        paginate (bool, optionnel): Pagination automatique.\n        format_output (str, optionnel): 'dataframe' ou 'dict'.\n\n    Returns:\n        GeoDataFrame des parcelles g\u00e9olocalis\u00e9es.\n    \"\"\"\n    # Validation des param\u00e8tres de localisation - m\u00eame contraintes que parcelles\n    checked_codes_insee, bbox_result, auto_contains_geom = (\n        self._validate_location_params(\n            code_insee=code_insee,\n            codes_insee=codes_insee,\n            coddep=None,\n            in_bbox=in_bbox,\n            lon_lat=lon_lat,\n            contains_lon_lat=contains_lon_lat,\n            max_bbox_size=0.02,\n            max_codes=10,\n        )\n    )\n\n    # Construction des param\u00e8tres\n    params = self._build_params(\n        code_insee=checked_codes_insee,\n        in_bbox=\",\".join(map(str, bbox_result)) if bbox_result else None,\n        contains_geom=auto_contains_geom,\n        catpro3=catpro3,\n        ctpdl=ctpdl,\n        dcntarti_min=dcntarti_min,\n        dcntarti_max=dcntarti_max,\n        dcntnaf_min=dcntnaf_min,\n        dcntnaf_max=dcntnaf_max,\n        dcntpa_min=dcntpa_min,\n        dcntpa_max=dcntpa_max,\n        idcomtxt=idcomtxt,\n        idpar=\",\".join(idpar) if idpar else None,\n        jannatmin_min=jannatmin_min,\n        jannatmin_max=jannatmin_max,\n        nlocal_min=nlocal_min,\n        nlocal_max=nlocal_max,\n        nlogh_min=nlogh_min,\n        nlogh_max=nlogh_max,\n        slocal_min=slocal_min,\n        slocal_max=slocal_max,\n        sprincp_min=sprincp_min,\n        sprincp_max=sprincp_max,\n        stoth_min=stoth_min,\n        stoth_max=stoth_max,\n        fields=fields,\n        page=page,\n        page_size=page_size,\n    )\n\n    return self._fetch(\n        endpoint=\"/ff/geoparcelles\",\n        params=params,\n        format_output=format_output,\n        geo=True,\n        paginate=paginate,\n    )\n</code></pre>"},{"location":"endpoints/ff/#exemples-dutilisation_2","title":"Exemples d'utilisation","text":"<ul> <li>Parcelles g\u00e9olocalis\u00e9es d'une commune : <pre><code>client.ff.geoparcelles(code_insee=\"59001\")\n</code></pre></li> <li>Parcelles g\u00e9olocalis\u00e9es dans une emprise : <pre><code>client.ff.geoparcelles(in_bbox=[2.76, 49.73, 2.779, 49.749])\n</code></pre></li> <li>Parcelles g\u00e9olocalis\u00e9es avec un propri\u00e9taire public : <pre><code>client.ff.geoparcelles(code_insee=\"59001\", catpro3=\"P\")\n</code></pre></li> </ul>"},{"location":"endpoints/ff/#fflocaux","title":"\ud83d\udcc2 <code>ff.locaux</code>","text":""},{"location":"endpoints/ff/#description_3","title":"Description","text":"<p>Retourne les locaux issus des Fichiers Fonciers pour la commune demand\u00e9e.</p> <p>Parameters:</p> Name Type Description Default <code>code_insee</code> <code>(str, obligatoire)</code> <p>Code INSEE communal ou d'arrondissement municipal (max 10, s\u00e9par\u00e9s par virgule).</p> required <code>catpro3</code> <code>(str, optionnel)</code> <p>Cat\u00e9gorie propri\u00e9taire.</p> <code>None</code> <code>dteloc</code> <code>(str, optionnel)</code> <p>Type(s) de local (s\u00e9par\u00e9s par virgule).</p> <code>None</code> <code>idpar</code> <code>(str, optionnel)</code> <p>Identifiant de parcelle.</p> <code>None</code> <code>idprocpte</code> <code>(str, optionnel)</code> <p>Identifiant de compte communal.</p> <code>None</code> <code>idsec</code> <code>(str, optionnel)</code> <p>Identifiant de section cadastrale.</p> <code>None</code> <code>locprop</code> <code>(List[str], optionnel)</code> <p>Localisation g\u00e9n\u00e9ralis\u00e9e du propri\u00e9taire (s\u00e9par\u00e9s par virgule).</p> <code>None</code> <code>loghlls</code> <code>(str, optionnel)</code> <p>Logement social rep\u00e9r\u00e9 par exon\u00e9ration.</p> <code>None</code> <code>proba_rprs</code> <code>(str, optionnel)</code> <p>Probabilit\u00e9 r\u00e9sidence principale/secondaire.</p> <code>None</code> <code>slocal_min</code> <code>(int, optionnel)</code> <p>Surface parties d'\u00e9valuation minimale (m2).</p> <code>None</code> <code>slocal_max</code> <code>(int, optionnel)</code> <p>Surface parties d'\u00e9valuation maximale (m2).</p> <code>None</code> <code>typeact</code> <code>(str, optionnel)</code> <p>Type d'activit\u00e9.</p> <code>None</code> <code>fields</code> <code>(str, optionnel)</code> <p>'all' pour obtenir tous les champs, None sinon.</p> <code>None</code> <code>ordering</code> <code>(str, optionnel)</code> <p>Champ de tri.</p> <code>None</code> <code>page</code> <code>(int, optionnel)</code> <p>Page de r\u00e9sultats.</p> <code>None</code> <code>page_size</code> <code>(int, optionnel)</code> <p>Nombre de r\u00e9sultats par page.</p> <code>500</code> <code>paginate</code> <code>(bool, optionnel)</code> <p>Pagination automatique.</p> <code>True</code> <code>format_output</code> <code>(str, optionnel)</code> <p>'dataframe' ou 'dict'.</p> <code>'dataframe'</code> <p>Returns:</p> Type Description <code>Union[DataFrame, List[dict]]</code> <p>DataFrame ou liste de dictionnaires des locaux.</p> Source code in <code>apifoncier\\endpoints\\ff.py</code> <pre><code>def locaux(\n    self,\n    code_insee: str,\n    # Filtres sp\u00e9cifiques locaux\n    catpro3: Optional[str] = None,\n    dteloc: Optional[str] = None,\n    idpar: Optional[str] = None,\n    idprocpte: Optional[str] = None,\n    idsec: Optional[str] = None,\n    locprop: Optional[List[str]] = None,\n    loghlls: Optional[str] = None,\n    proba_rprs: Optional[str] = None,\n    slocal_min: Optional[int] = None,\n    slocal_max: Optional[int] = None,\n    typeact: Optional[str] = None,\n    fields: Optional[str] = None,\n    ordering: Optional[str] = None,\n    page: Optional[int] = None,\n    page_size: Optional[int] = 500,\n    paginate: bool = True,\n    format_output: str = \"dataframe\",\n) -&gt; Union[pd.DataFrame, List[dict]]:\n    \"\"\"\n    Retourne les locaux issus des Fichiers Fonciers pour la commune demand\u00e9e.\n\n    Args:\n        code_insee (str, obligatoire): Code INSEE communal ou d'arrondissement municipal (max 10, s\u00e9par\u00e9s par virgule).\n        catpro3 (str, optionnel): Cat\u00e9gorie propri\u00e9taire.\n        dteloc (str, optionnel): Type(s) de local (s\u00e9par\u00e9s par virgule).\n        idpar (str, optionnel): Identifiant de parcelle.\n        idprocpte (str, optionnel): Identifiant de compte communal.\n        idsec (str, optionnel): Identifiant de section cadastrale.\n        locprop (List[str], optionnel): Localisation g\u00e9n\u00e9ralis\u00e9e du propri\u00e9taire (s\u00e9par\u00e9s par virgule).\n        loghlls (str, optionnel): Logement social rep\u00e9r\u00e9 par exon\u00e9ration.\n        proba_rprs (str, optionnel): Probabilit\u00e9 r\u00e9sidence principale/secondaire.\n        slocal_min (int, optionnel): Surface parties d'\u00e9valuation minimale (m2).\n        slocal_max (int, optionnel): Surface parties d'\u00e9valuation maximale (m2).\n        typeact (str, optionnel): Type d'activit\u00e9.\n        fields (str, optionnel): 'all' pour obtenir tous les champs, None sinon.\n        ordering (str, optionnel): Champ de tri.\n        page (int, optionnel): Page de r\u00e9sultats.\n        page_size (int, optionnel): Nombre de r\u00e9sultats par page.\n        paginate (bool, optionnel): Pagination automatique.\n        format_output (str, optionnel): 'dataframe' ou 'dict'.\n\n    Returns:\n        DataFrame ou liste de dictionnaires des locaux.\n    \"\"\"\n    # /ff/locaux : code_insee obligatoire (pas d'in_bbox)\n    checked_codes_insee, _, _ = self._validate_location_params(\n        code_insee=code_insee,\n        codes_insee=None,\n        coddep=None,\n        in_bbox=None,\n        lon_lat=None,\n        contains_lon_lat=None,\n        max_bbox_size=0.02,\n        max_codes=10,\n    )\n\n    # Construction des param\u00e8tres\n    params = self._build_params(\n        code_insee=checked_codes_insee,\n        catpro3=catpro3,\n        dteloc=dteloc,\n        idpar=idpar,\n        idprocpte=idprocpte,\n        idsec=idsec,\n        locprop=\",\".join(locprop) if locprop else None,\n        loghlls=loghlls,\n        proba_rprs=proba_rprs,\n        slocal_min=slocal_min,\n        slocal_max=slocal_max,\n        typeact=typeact,\n        fields=fields,\n        ordering=ordering,\n        page=page,\n        page_size=page_size,\n    )\n\n    return self._fetch(\n        endpoint=\"/ff/locaux\",\n        params=params,\n        format_output=format_output,\n        geo=False,\n        paginate=paginate,\n    )\n</code></pre>"},{"location":"endpoints/ff/#exemples-dutilisation_3","title":"Exemples d'utilisation","text":"<ul> <li>Locaux d'une commune : <pre><code>client.ff.locaux(code_insee=\"59001\")\n</code></pre></li> <li>Locaux de type \"appartement\" (dteloc=\"2\") dans la commune de Lille (59350) avec une surface minimale de 180 m\u00b2 : <pre><code>client.ff.locaux(code_insee=\"59350\", dteloc=\"2\", slocal_min=180)\n</code></pre></li> </ul>"},{"location":"endpoints/ff/#fflocal_by_id","title":"\ud83d\udcc2 <code>ff.local_by_id</code>","text":""},{"location":"endpoints/ff/#description_4","title":"Description","text":"<p>Retourne le local des Fichiers fonciers pour l'identifiant fiscal du local demand\u00e9.</p> <p>Parameters:</p> Name Type Description Default <code>idlocal</code> <code>(str, obligatoire)</code> <p>Identifiant fiscal du local.</p> required <code>format_output</code> <code>(str, optionnel)</code> <p>'dict'.</p> <code>'dict'</code> <p>Returns:</p> Type Description <code>Union[dict, List[dict]]</code> <p>Dictionnaire du local.</p> Source code in <code>apifoncier\\endpoints\\ff.py</code> <pre><code>def local_by_id(\n    self,\n    idlocal: str,\n    format_output: str = \"dict\",\n) -&gt; Union[dict, List[dict]]:\n    \"\"\"\n    Retourne le local des Fichiers fonciers pour l'identifiant fiscal du local demand\u00e9.\n\n    Args:\n        idlocal (str, obligatoire): Identifiant fiscal du local.\n        format_output (str, optionnel): 'dict'.\n\n    Returns:\n        Dictionnaire du local.\n    \"\"\"\n    if not idlocal:\n        raise ValidationError(\"idlocal est obligatoire\")\n\n    # Pas de pagination pour un local unique\n    return self._fetch(\n        endpoint=f\"/ff/locaux/{idlocal}\",\n        params={},\n        format_output=format_output,\n        geo=False,\n        paginate=False,\n    )\n</code></pre>"},{"location":"endpoints/ff/#exemples-dutilisation_4","title":"Exemples d'utilisation","text":"<ul> <li>Local par identifiant : <pre><code>client.ff.local_by_id(idlocal=\"592980433303\")\n</code></pre></li> </ul>"},{"location":"endpoints/ff/#fftups","title":"\ud83d\udcc2 <code>ff.tups</code>","text":""},{"location":"endpoints/ff/#description_5","title":"Description","text":"<p>Retourne les TUPs issues des Fichiers Fonciers pour la commune ou l'emprise demand\u00e9e.</p> <p>Parameters:</p> Name Type Description Default <code>code_insee</code> <code>(str, optionnel)</code> <p>Code INSEE communal ou d'arrondissement municipal (max 10, s\u00e9par\u00e9s par virgule).</p> <code>None</code> <code>codes_insee</code> <code>(List[str], optionnel)</code> <p>Liste de codes INSEE.</p> <code>None</code> <code>in_bbox</code> <code>(List[float], optionnel)</code> <p>[xmin, ymin, xmax, ymax], max 0.02\u00b0 x 0.02\u00b0.</p> <code>None</code> <code>lon_lat</code> <code>(List[float], optionnel)</code> <p>Coordonn\u00e9es [lon, lat].</p> <code>None</code> <code>contains_lon_lat</code> <code>(List[float], optionnel)</code> <p>Coordonn\u00e9es \u00e0 contenir [lon, lat].</p> <code>None</code> <code>catpro3</code> <code>(str, optionnel)</code> <p>Cat\u00e9gorie propri\u00e9taire.</p> <code>None</code> <code>fields</code> <code>(str, optionnel)</code> <p>Champs \u00e0 retourner.</p> <code>None</code> <code>idtup</code> <code>(List[str], optionnel)</code> <p>Identifiants de TUP (max 10, s\u00e9par\u00e9s par virgule).</p> <code>None</code> <code>typetup</code> <code>(str, optionnel)</code> <p>Type de TUP (SIMPLE, PDLMP, UF).</p> <code>None</code> <code>ordering</code> <code>(str, optionnel)</code> <p>Champ de tri.</p> <code>None</code> <code>page</code> <code>(int, optionnel)</code> <p>Page de r\u00e9sultats.</p> <code>None</code> <code>page_size</code> <code>(int, optionnel)</code> <p>Nombre de r\u00e9sultats par page.</p> <code>500</code> <code>paginate</code> <code>(bool, optionnel)</code> <p>Pagination automatique.</p> <code>True</code> <code>format_output</code> <code>(str, optionnel)</code> <p>'dataframe' ou 'dict'.</p> <code>'dataframe'</code> <p>Returns:</p> Type Description <code>Union[DataFrame, List[dict]]</code> <p>DataFrame ou liste de dictionnaires des TUPs.</p> Source code in <code>apifoncier\\endpoints\\ff.py</code> <pre><code>def tups(\n    self,\n    code_insee: Optional[str] = None,\n    codes_insee: Optional[List[str]] = None,\n    in_bbox: Optional[List[float]] = None,\n    lon_lat: Optional[List[float]] = None,\n    contains_lon_lat: Optional[List[float]] = None,\n    catpro3: Optional[str] = None,\n    fields: Optional[str] = None,\n    idtup: Optional[List[str]] = None,\n    typetup: Optional[str] = None,\n    ordering: Optional[str] = None,\n    page: Optional[int] = None,\n    page_size: Optional[int] = 500,\n    paginate: bool = True,\n    format_output: str = \"dataframe\",\n) -&gt; Union[pd.DataFrame, List[dict]]:\n    \"\"\"\n    Retourne les TUPs issues des Fichiers Fonciers pour la commune ou l'emprise demand\u00e9e.\n\n    Args:\n        code_insee (str, optionnel): Code INSEE communal ou d'arrondissement municipal (max 10, s\u00e9par\u00e9s par virgule).\n        codes_insee (List[str], optionnel): Liste de codes INSEE.\n        in_bbox (List[float], optionnel): [xmin, ymin, xmax, ymax], max 0.02\u00b0 x 0.02\u00b0.\n        lon_lat (List[float], optionnel): Coordonn\u00e9es [lon, lat].\n        contains_lon_lat (List[float], optionnel): Coordonn\u00e9es \u00e0 contenir [lon, lat].\n        catpro3 (str, optionnel): Cat\u00e9gorie propri\u00e9taire.\n        fields (str, optionnel): Champs \u00e0 retourner.\n        idtup (List[str], optionnel): Identifiants de TUP (max 10, s\u00e9par\u00e9s par virgule).\n        typetup (str, optionnel): Type de TUP (SIMPLE, PDLMP, UF).\n        ordering (str, optionnel): Champ de tri.\n        page (int, optionnel): Page de r\u00e9sultats.\n        page_size (int, optionnel): Nombre de r\u00e9sultats par page.\n        paginate (bool, optionnel): Pagination automatique.\n        format_output (str, optionnel): 'dataframe' ou 'dict'.\n\n    Returns:\n        DataFrame ou liste de dictionnaires des TUPs.\n    \"\"\"\n    checked_codes_insee, bbox_result, auto_contains_geom = (\n        self._validate_location_params(\n            code_insee=code_insee,\n            codes_insee=codes_insee,\n            coddep=None,\n            in_bbox=in_bbox,\n            lon_lat=lon_lat,\n            contains_lon_lat=contains_lon_lat,\n            max_bbox_size=0.02,\n            max_codes=10,\n        )\n    )\n    params = self._build_params(\n        code_insee=checked_codes_insee,\n        in_bbox=\",\".join(map(str, bbox_result)) if bbox_result else None,\n        contains_geom=auto_contains_geom,\n        catpro3=catpro3,\n        fields=fields,\n        idtup=\",\".join(idtup) if idtup else None,\n        typetup=typetup,\n        ordering=ordering,\n        page=page,\n        page_size=page_size,\n    )\n    return self._fetch(\n        endpoint=\"/ff/tups\",\n        params=params,\n        format_output=format_output,\n        geo=False,\n        paginate=paginate,\n    )\n</code></pre>"},{"location":"endpoints/ff/#exemples-dutilisation_5","title":"Exemples d'utilisation","text":"<ul> <li>TUPs d'une commune : <pre><code>client.ff.tups(code_insee=\"59001\")\n</code></pre></li> <li>TUPs de type \"unit\u00e9 fonci\u00e8re\" (typetup=\"UF\") appartenant \u00e0 des propri\u00e9taires publics (catpro3=\"P\") : <pre><code>client.ff.tups(code_insee=\"59001\", typetup=\"UF\", catpro3=\"P\")\n</code></pre></li> <li>TUPs avec plusieurs identifiants : <pre><code>client.ff.tups(bbox=[2.76, 49.73, 2.779, 49.749], )\n</code></pre></li> </ul>"},{"location":"endpoints/ff/#fftup_by_id","title":"\ud83d\udcc2 <code>ff.tup_by_id</code>","text":""},{"location":"endpoints/ff/#description_6","title":"Description","text":"<p>Retourne la TUP des Fichiers fonciers pour l'identifiant idtup demand\u00e9.</p> <p>Parameters:</p> Name Type Description Default <code>idtup</code> <code>(str, obligatoire)</code> <p>Identifiant de la TUP.</p> required <code>format_output</code> <code>(str, optionnel)</code> <p>'dict'.</p> <code>'dict'</code> <p>Returns:</p> Type Description <code>Union[dict, List[dict]]</code> <p>Dictionnaire de la TUP.</p> Source code in <code>apifoncier\\endpoints\\ff.py</code> <pre><code>def tup_by_id(\n    self,\n    idtup: str,\n    format_output: str = \"dict\",\n) -&gt; Union[dict, List[dict]]:\n    \"\"\"\n    Retourne la TUP des Fichiers fonciers pour l'identifiant idtup demand\u00e9.\n\n    Args:\n        idtup (str, obligatoire): Identifiant de la TUP.\n        format_output (str, optionnel): 'dict'.\n\n    Returns:\n        Dictionnaire de la TUP.\n    \"\"\"\n    if not idtup:\n        raise ValidationError(\"idtup est obligatoire\")\n    return self._fetch(\n        endpoint=f\"/ff/tups/{idtup}\",\n        params={},\n        format_output=format_output,\n        geo=False,\n        paginate=False,\n    )\n</code></pre>"},{"location":"endpoints/ff/#exemples-dutilisation_6","title":"Exemples d'utilisation","text":"<ul> <li>TUP par identifiant : <pre><code>client.ff.tup_by_id(\"uf590010396107\")\n</code></pre></li> </ul>"},{"location":"endpoints/ff/#ffgeotups","title":"\ud83d\udcc2 <code>ff.geotups</code>","text":""},{"location":"endpoints/ff/#description_7","title":"Description","text":"<p>Retourne, en GeoJSON, les TUPs issues des Fichiers Fonciers pour la commune ou l'emprise demand\u00e9e.</p> <p>Parameters:</p> Name Type Description Default <code>code_insee</code> <code>(str, optionnel)</code> <p>Code INSEE communal ou d'arrondissement municipal (max 10, s\u00e9par\u00e9s par virgule).</p> <code>None</code> <code>codes_insee</code> <code>(List[str], optionnel)</code> <p>Liste de codes INSEE.</p> <code>None</code> <code>in_bbox</code> <code>(List[float], optionnel)</code> <p>[xmin, ymin, xmax, ymax], max 0.02\u00b0 x 0.02\u00b0.</p> <code>None</code> <code>lon_lat</code> <code>(List[float], optionnel)</code> <p>Coordonn\u00e9es [lon, lat].</p> <code>None</code> <code>contains_lon_lat</code> <code>(List[float], optionnel)</code> <p>Coordonn\u00e9es \u00e0 contenir [lon, lat].</p> <code>None</code> <code>catpro3</code> <code>(str, optionnel)</code> <p>Cat\u00e9gorie propri\u00e9taire.</p> <code>None</code> <code>fields</code> <code>(str, optionnel)</code> <p>Champs \u00e0 retourner.</p> <code>None</code> <code>idtup</code> <code>(List[str], optionnel)</code> <p>Identifiants de TUP (max 10, s\u00e9par\u00e9s par virgule).</p> <code>None</code> <code>typetup</code> <code>(str, optionnel)</code> <p>Type de TUP (SIMPLE, PDLMP, UF).</p> <code>None</code> <code>page</code> <code>(int, optionnel)</code> <p>Page de r\u00e9sultats.</p> <code>None</code> <code>page_size</code> <code>(int, optionnel)</code> <p>Nombre de r\u00e9sultats par page.</p> <code>500</code> <code>paginate</code> <code>(bool, optionnel)</code> <p>Pagination automatique.</p> <code>True</code> <code>format_output</code> <code>(str, optionnel)</code> <p>'dataframe' ou 'dict'.</p> <code>'dataframe'</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>GeoDataFrame des TUPs g\u00e9olocalis\u00e9es.</p> Source code in <code>apifoncier\\endpoints\\ff.py</code> <pre><code>def geotups(\n    self,\n    code_insee: Optional[str] = None,\n    codes_insee: Optional[List[str]] = None,\n    in_bbox: Optional[List[float]] = None,\n    lon_lat: Optional[List[float]] = None,\n    contains_lon_lat: Optional[List[float]] = None,\n    catpro3: Optional[str] = None,\n    fields: Optional[str] = None,\n    idtup: Optional[List[str]] = None,\n    typetup: Optional[str] = None,\n    page: Optional[int] = None,\n    page_size: Optional[int] = 500,\n    paginate: bool = True,\n    format_output: str = \"dataframe\",\n) -&gt; gpd.GeoDataFrame:\n    \"\"\"\n    Retourne, en GeoJSON, les TUPs issues des Fichiers Fonciers pour la commune ou l'emprise demand\u00e9e.\n\n    Args:\n        code_insee (str, optionnel): Code INSEE communal ou d'arrondissement municipal (max 10, s\u00e9par\u00e9s par virgule).\n        codes_insee (List[str], optionnel): Liste de codes INSEE.\n        in_bbox (List[float], optionnel): [xmin, ymin, xmax, ymax], max 0.02\u00b0 x 0.02\u00b0.\n        lon_lat (List[float], optionnel): Coordonn\u00e9es [lon, lat].\n        contains_lon_lat (List[float], optionnel): Coordonn\u00e9es \u00e0 contenir [lon, lat].\n        catpro3 (str, optionnel): Cat\u00e9gorie propri\u00e9taire.\n        fields (str, optionnel): Champs \u00e0 retourner.\n        idtup (List[str], optionnel): Identifiants de TUP (max 10, s\u00e9par\u00e9s par virgule).\n        typetup (str, optionnel): Type de TUP (SIMPLE, PDLMP, UF).\n        page (int, optionnel): Page de r\u00e9sultats.\n        page_size (int, optionnel): Nombre de r\u00e9sultats par page.\n        paginate (bool, optionnel): Pagination automatique.\n        format_output (str, optionnel): 'dataframe' ou 'dict'.\n\n    Returns:\n        GeoDataFrame des TUPs g\u00e9olocalis\u00e9es.\n    \"\"\"\n    # Validation des param\u00e8tres de localisation\n    checked_codes_insee, bbox_result, auto_contains_geom = (\n        self._validate_location_params(\n            code_insee=code_insee,\n            codes_insee=codes_insee,\n            coddep=None,\n            in_bbox=in_bbox,\n            lon_lat=lon_lat,\n            contains_lon_lat=contains_lon_lat,\n            max_bbox_size=0.02,\n            max_codes=10,\n        )\n    )\n\n    # Construction des param\u00e8tres\n    params = self._build_params(\n        code_insee=checked_codes_insee,\n        in_bbox=\",\".join(map(str, bbox_result)) if bbox_result else None,\n        contains_geom=auto_contains_geom,\n        catpro3=catpro3,\n        fields=fields,\n        idtup=\",\".join(idtup) if idtup else None,\n        typetup=typetup,\n        page=page,\n        page_size=page_size,\n    )\n\n    return self._fetch(\n        endpoint=\"/ff/geotups\",\n        params=params,\n        format_output=format_output,\n        geo=True,\n        paginate=paginate,\n    )\n</code></pre>"},{"location":"endpoints/ff/#exemples-dutilisation_7","title":"Exemples d'utilisation","text":"<ul> <li>TUPs g\u00e9olocalis\u00e9es d'une commune : <pre><code>client.ff.geotups(code_insee=\"59001\")\n</code></pre></li> <li>TUPs g\u00e9olocalis\u00e9es avec filtre propri\u00e9taire : <pre><code>client.ff.geotups(code_insee=\"59001\", catpro3=\"P\")\n</code></pre></li> </ul>"},{"location":"endpoints/ff/#ffproprios","title":"\ud83d\udcc2 <code>ff.proprios</code>","text":""},{"location":"endpoints/ff/#description_8","title":"Description","text":"<p>Retourne les droits de propri\u00e9t\u00e9 issus des Fichiers Fonciers pour la commune demand\u00e9e.</p> <p>Parameters:</p> Name Type Description Default <code>code_insee</code> <code>(str, obligatoire)</code> <p>Code INSEE communal ou d'arrondissement municipal (max 10, s\u00e9par\u00e9s par virgule).</p> required <code>catpro3</code> <code>(str, optionnel)</code> <p>Cat\u00e9gorie propri\u00e9taire.</p> <code>None</code> <code>ccodro</code> <code>(str, optionnel)</code> <p>Code(s) du droit r\u00e9el ou particulier (s\u00e9par\u00e9s par virgule).</p> <code>None</code> <code>fields</code> <code>(str, optionnel)</code> <p>Champs \u00e0 retourner.</p> <code>None</code> <code>gtoper</code> <code>(str, optionnel)</code> <p>Indicateur personne physique/morale.</p> <code>None</code> <code>idprocpte</code> <code>(str, optionnel)</code> <p>Identifiant de compte communal.</p> <code>None</code> <code>locprop</code> <code>(str, optionnel)</code> <p>Localisation g\u00e9n\u00e9ralis\u00e9e du propri\u00e9taire.</p> <code>None</code> <code>ordering</code> <code>(str, optionnel)</code> <p>Champ de tri.</p> <code>None</code> <code>page</code> <code>(int, optionnel)</code> <p>Page de r\u00e9sultats.</p> <code>None</code> <code>page_size</code> <code>(int, optionnel)</code> <p>Nombre de r\u00e9sultats par page.</p> <code>500</code> <code>typedroit</code> <code>(str, optionnel)</code> <p>Type de droit (propri\u00e9taire/gestionnaire).</p> <code>None</code> <code>paginate</code> <code>(bool, optionnel)</code> <p>Pagination automatique.</p> <code>True</code> <code>format_output</code> <code>(str, optionnel)</code> <p>'dataframe' ou 'dict'.</p> <code>'dataframe'</code> <p>Returns:</p> Type Description <code>Union[DataFrame, List[dict]]</code> <p>DataFrame ou liste de dictionnaires des droits de propri\u00e9t\u00e9.</p> Source code in <code>apifoncier\\endpoints\\ff.py</code> <pre><code>def proprios(\n    self,\n    code_insee: str,\n    catpro3: Optional[str] = None,\n    ccodro: Optional[str] = None,\n    fields: Optional[str] = None,\n    gtoper: Optional[str] = None,\n    idprocpte: Optional[str] = None,\n    locprop: Optional[str] = None,\n    ordering: Optional[str] = None,\n    page: Optional[int] = None,\n    page_size: Optional[int] = 500,\n    paginate: bool = True,\n    typedroit: Optional[str] = None,\n    format_output: str = \"dataframe\",\n) -&gt; Union[pd.DataFrame, List[dict]]:\n    \"\"\"\n    Retourne les droits de propri\u00e9t\u00e9 issus des Fichiers Fonciers pour la commune demand\u00e9e.\n\n    Args:\n        code_insee (str, obligatoire): Code INSEE communal ou d'arrondissement municipal (max 10, s\u00e9par\u00e9s par virgule).\n        catpro3 (str, optionnel): Cat\u00e9gorie propri\u00e9taire.\n        ccodro (str, optionnel): Code(s) du droit r\u00e9el ou particulier (s\u00e9par\u00e9s par virgule).\n        fields (str, optionnel): Champs \u00e0 retourner.\n        gtoper (str, optionnel): Indicateur personne physique/morale.\n        idprocpte (str, optionnel): Identifiant de compte communal.\n        locprop (str, optionnel): Localisation g\u00e9n\u00e9ralis\u00e9e du propri\u00e9taire.\n        ordering (str, optionnel): Champ de tri.\n        page (int, optionnel): Page de r\u00e9sultats.\n        page_size (int, optionnel): Nombre de r\u00e9sultats par page.\n        typedroit (str, optionnel): Type de droit (propri\u00e9taire/gestionnaire).\n        paginate (bool, optionnel): Pagination automatique.\n        format_output (str, optionnel): 'dataframe' ou 'dict'.\n\n    Returns:\n        DataFrame ou liste de dictionnaires des droits de propri\u00e9t\u00e9.\n    \"\"\"\n    checked_codes_insee, _, _ = self._validate_location_params(\n        code_insee=code_insee,\n        codes_insee=None,\n        coddep=None,\n        in_bbox=None,\n        lon_lat=None,\n        contains_lon_lat=None,\n        max_bbox_size=0.02,\n        max_codes=10,\n    )\n    params = self._build_params(\n        code_insee=checked_codes_insee,\n        catpro3=catpro3,\n        ccodro=ccodro,\n        fields=fields,\n        gtoper=gtoper,\n        idprocpte=idprocpte,\n        locprop=locprop,\n        ordering=ordering,\n        page=page,\n        page_size=page_size,\n        typedroit=typedroit,\n    )\n    return self._fetch(\n        endpoint=\"/ff/proprios\",\n        params=params,\n        format_output=format_output,\n        geo=False,\n        paginate=paginate,\n    )\n</code></pre>"},{"location":"endpoints/ff/#exemples-dutilisation_8","title":"Exemples d'utilisation","text":"<ul> <li>Droits de propri\u00e9t\u00e9 d'une commune : <pre><code>client.ff.proprios(code_insee=\"59001\")\n</code></pre></li> <li>Droits de propri\u00e9t\u00e9 avec filtre sur cat\u00e9gorie publique : <pre><code>client.ff.proprios(code_insee=\"59001\", catpro3=\"P\")\n</code></pre></li> <li>Droits de propri\u00e9t\u00e9 avec droit de propri\u00e9t\u00e9 de type GERANT,MANDATAIRE (ccodro) : <pre><code>client.ff.proprios(code_insee=\"59001\", ccodro=\"G\", fields=\"all\")\n</code></pre></li> </ul>"},{"location":"endpoints/ff/#ffproprio_by_id","title":"\ud83d\udcc2 <code>ff.proprio_by_id</code>","text":""},{"location":"endpoints/ff/#description_9","title":"Description","text":"<p>Retourne le droit de propri\u00e9t\u00e9 des Fichiers fonciers pour l'identifiant idprodroit demand\u00e9.</p> <p>Parameters:</p> Name Type Description Default <code>idprodroit</code> <code>(str, obligatoire)</code> <p>Identifiant du droit de propri\u00e9t\u00e9.</p> required <code>format_output</code> <code>(str, optionnel)</code> <p>'dict'.</p> <code>'dict'</code> <p>Returns:</p> Type Description <code>Union[dict, List[dict]]</code> <p>Dictionnaire du droit de propri\u00e9t\u00e9.</p> Source code in <code>apifoncier\\endpoints\\ff.py</code> <pre><code>def proprio_by_id(\n    self,\n    idprodroit: str,\n    format_output: str = \"dict\",\n) -&gt; Union[dict, List[dict]]:\n    \"\"\"\n    Retourne le droit de propri\u00e9t\u00e9 des Fichiers fonciers pour l'identifiant idprodroit demand\u00e9.\n\n    Args:\n        idprodroit (str, obligatoire): Identifiant du droit de propri\u00e9t\u00e9.\n        format_output (str, optionnel): 'dict'.\n\n    Returns:\n        Dictionnaire du droit de propri\u00e9t\u00e9.\n    \"\"\"\n    if not idprodroit:\n        raise ValidationError(\"idprodroit est obligatoire\")\n    return self._fetch(\n        endpoint=f\"/ff/proprios/{idprodroit}\",\n        params={},\n        format_output=format_output,\n        geo=False,\n        paginate=False,\n    )\n</code></pre>"},{"location":"endpoints/ff/#exemples-dutilisation_9","title":"Exemples d'utilisation","text":"<ul> <li>Droit de propri\u00e9t\u00e9 par identifiant : <pre><code>client.ff.proprio_by_id(idprodroit=\"59001D0017702\")\n</code></pre></li> </ul>"},{"location":"endpoints/indicateurs/","title":"Indicateurs - principaux endpoints","text":"<p>Permet d'interroger les indicateurs de consommation d'espace ainsi que les indicateurs de march\u00e9 : accessibilit\u00e9, activit\u00e9, prix et valorisation.</p>"},{"location":"endpoints/indicateurs/#indicateursconso","title":"\ud83d\udcc2 <code>indicateurs.conso</code>","text":""},{"location":"endpoints/indicateurs/#description","title":"Description","text":"<p>Renvoie les indicateurs de consommation d'espace pour la p\u00e9riode comprise entre annee_min et annee_max, bornes incluses.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>(str, obligatoire)</code> <p>Code INSEE communal ou d\u00e9partemental.</p> required <code>echelle</code> <code>(str, obligatoire)</code> <p>'communes' ou 'departements'.</p> required <code>annee</code> <code>(int, optionnel)</code> <p>Ann\u00e9e sp\u00e9cifique.</p> <code>None</code> <code>annee_min</code> <code>(int, optionnel)</code> <p>Ann\u00e9e minimale.</p> <code>None</code> <code>annee_max</code> <code>(int, optionnel)</code> <p>Ann\u00e9e maximale.</p> <code>None</code> <code>ordering</code> <code>(str, optionnel)</code> <p>Champ de tri.</p> <code>None</code> <code>page</code> <code>(int, optionnel)</code> <p>Page de r\u00e9sultats.</p> <code>None</code> <code>page_size</code> <code>(int, optionnel)</code> <p>Nombre de r\u00e9sultats par page.</p> <code>500</code> <code>paginate</code> <code>(bool, optionnel)</code> <p>Pagination automatique.</p> <code>True</code> <code>format_output</code> <code>(str, optionnel)</code> <p>'dataframe' ou 'dict'.</p> <code>'dataframe'</code> <code>fields</code> <code>(str, optionnel)</code> <p>'all' pour obtenir tous les champs, None sinon.</p> required <p>Returns:</p> Type Description <code>Union[DataFrame, List[dict]]</code> <p>DataFrame ou liste de dictionnaires avec les indicateurs de consommation d'espace.</p> Source code in <code>apifoncier\\endpoints\\indicateurs.py</code> <pre><code>def conso(\n    self,\n    code: str,\n    echelle: str,\n    annee: Optional[int] = None,\n    annee_min: Optional[int] = None,\n    annee_max: Optional[int] = None,\n    ordering: Optional[str] = None,\n    page: Optional[int] = None,\n    page_size: Optional[int] = 500,\n    paginate: bool = True,\n    format_output: str = \"dataframe\",\n) -&gt; Union[pd.DataFrame, List[dict]]:\n    \"\"\"\n    Renvoie les indicateurs de consommation d'espace pour la p\u00e9riode comprise entre annee_min et annee_max, bornes incluses.\n\n    Args:\n        code (str, obligatoire): Code INSEE communal ou d\u00e9partemental.\n        echelle (str, obligatoire): 'communes' ou 'departements'.\n        annee (int, optionnel): Ann\u00e9e sp\u00e9cifique.\n        annee_min (int, optionnel): Ann\u00e9e minimale.\n        annee_max (int, optionnel): Ann\u00e9e maximale.\n        ordering (str, optionnel): Champ de tri.\n        page (int, optionnel): Page de r\u00e9sultats.\n        page_size (int, optionnel): Nombre de r\u00e9sultats par page.\n        paginate (bool, optionnel): Pagination automatique.\n        format_output (str, optionnel): 'dataframe' ou 'dict'.\n        fields (str, optionnel): 'all' pour obtenir tous les champs, None sinon.\n\n    Returns:\n        DataFrame ou liste de dictionnaires avec les indicateurs de consommation d'espace.\n    \"\"\"\n    if not code:\n        raise ValidationError(\"Le param\u00e8tre 'code' est obligatoire\")\n    if echelle not in [\"communes\", \"departements\"]:\n        raise ValidationError(\"L'\u00e9chelle doit \u00eatre 'communes' ou 'departements'\")\n\n    params = self._build_params(\n        annee=annee,\n        annee_min=annee_min,\n        annee_max=annee_max,\n        ordering=ordering,\n        page=page,\n        page_size=page_size,\n    )\n\n    return self._fetch(\n        endpoint=f\"/indicateurs/conso_espace/{echelle}/{code}\",\n        params=params,\n        format_output=format_output,\n        geo=False,\n        paginate=paginate,\n    )\n</code></pre>"},{"location":"endpoints/indicateurs/#exemples-dutilisation","title":"Exemples d'utilisation","text":"<ul> <li>Consommation d'espace pour une commune :   <pre><code>client.indicateurs.conso(code=\"59001\", echelle=\"communes\")\n</code></pre></li> <li>Consommation d'espace pour un d\u00e9partement :   <pre><code>client.indicateurs.conso(code=\"62\", echelle=\"departements\")\n</code></pre></li> <li>Consommation d'espace sur une p\u00e9riode :   <pre><code>client.indicateurs.conso(code=\"59001\", echelle=\"communes\", annee_min=2015, annee_max=2022)\n</code></pre></li> <li>Consommation d'espace avec tri :   <pre><code>client.indicateurs.conso(code=\"59001\", echelle=\"communes\", ordering=\"-annee\")\n</code></pre></li> </ul>"},{"location":"endpoints/indicateurs/#indicateursaccessibilite","title":"\ud83d\udcc2 <code>indicateurs.accessibilite</code>","text":""},{"location":"endpoints/indicateurs/#description_1","title":"Description","text":"<p>Retourne les indicateurs d'accessibilit\u00e9 financi\u00e8re tri-annuels issus de DV3F.</p> <p>Parameters:</p> Name Type Description Default <code>codes_aav</code> <code>str ou List[str], obligatoire</code> <p>Code(s) INSEE d'une aire d'attraction des villes (max 10).</p> required <code>annee</code> <code>(str, optionnel)</code> <p>Ann\u00e9e.</p> <code>None</code> <code>ordering</code> <code>(str, optionnel)</code> <p>Champ de tri.</p> <code>None</code> <code>page</code> <code>(int, optionnel)</code> <p>Page de r\u00e9sultats.</p> <code>None</code> <code>page_size</code> <code>(int, optionnel)</code> <p>Nombre de r\u00e9sultats par page.</p> <code>500</code> <code>paginate</code> <code>(bool, optionnel)</code> <p>Pagination automatique.</p> <code>True</code> <code>format_output</code> <code>(str, optionnel)</code> <p>'dataframe' ou 'dict'.</p> <code>'dataframe'</code> <code>fields</code> <code>(str, optionnel)</code> <p>'all' pour obtenir tous les champs, None sinon.</p> required <p>Returns:</p> Type Description <code>Union[DataFrame, List[dict]]</code> <p>DataFrame ou liste de dictionnaires avec les indicateurs d'accessibilit\u00e9.</p> Source code in <code>apifoncier\\endpoints\\indicateurs.py</code> <pre><code>def accessibilite(\n    self,\n    codes_aav: Union[str, List[str]],\n    annee: Optional[str] = None,\n    ordering: Optional[str] = None,\n    page: Optional[int] = None,\n    page_size: Optional[int] = 500,\n    paginate: bool = True,\n    format_output: str = \"dataframe\",\n) -&gt; Union[pd.DataFrame, List[dict]]:\n    \"\"\"\n    Retourne les indicateurs d'accessibilit\u00e9 financi\u00e8re tri-annuels issus de DV3F.\n\n    Args:\n        codes_aav (str ou List[str], obligatoire): Code(s) INSEE d'une aire d'attraction des villes (max 10).\n        annee (str, optionnel): Ann\u00e9e.\n        ordering (str, optionnel): Champ de tri.\n        page (int, optionnel): Page de r\u00e9sultats.\n        page_size (int, optionnel): Nombre de r\u00e9sultats par page.\n        paginate (bool, optionnel): Pagination automatique.\n        format_output (str, optionnel): 'dataframe' ou 'dict'.\n        fields (str, optionnel): 'all' pour obtenir tous les champs, None sinon.\n\n    Returns:\n        DataFrame ou liste de dictionnaires avec les indicateurs d'accessibilit\u00e9.\n    \"\"\"\n    if not codes_aav:\n        raise ValidationError(\"Le param\u00e8tre 'codes_aav' est obligatoire\")\n\n    processed_codes = self._process_codes(codes_aav, max_codes=10)\n\n    params = self._build_params(\n        code=processed_codes,\n        annee=annee,\n        ordering=ordering,\n        page=page,\n        page_size=page_size,\n    )\n\n    return self._fetch(\n        endpoint=\"/indicateurs/dv3f/accessibilite\",\n        params=params,\n        format_output=format_output,\n        geo=False,\n        paginate=paginate,\n    )\n</code></pre>"},{"location":"endpoints/indicateurs/#exemples-dutilisation_1","title":"Exemples d'utilisation","text":"<ul> <li>Accessibilit\u00e9 pour une AAV :   <pre><code>client.indicateurs.accessibilite(codes_aav=\"001\")\n</code></pre></li> <li>Accessibilit\u00e9 pour plusieurs AAV :   <pre><code>client.indicateurs.accessibilite(codes_aav=[\"004\", \"005\"])\n</code></pre></li> <li>Accessibilit\u00e9 pour une ann\u00e9e donn\u00e9e :   <pre><code>client.indicateurs.accessibilite(codes_aav=\"004\", annee=\"2021\")\n</code></pre></li> </ul>"},{"location":"endpoints/indicateurs/#indicateursactivite","title":"\ud83d\udcc2 <code>indicateurs.activite</code>","text":""},{"location":"endpoints/indicateurs/#description_2","title":"Description","text":"<p>Renvoie les indicateurs d'activit\u00e9 du march\u00e9 tri-annuels issus de DV3F.</p> <p>Parameters:</p> Name Type Description Default <code>codes</code> <code>str ou List[str], obligatoire</code> <p>Code(s) INSEE g\u00e9ographique(s) associ\u00e9(s) \u00e0 l'\u00e9chelle (max 10).</p> required <code>echelle</code> <code>(str, obligatoire)</code> <p>'communes', 'epci', 'aav', 'departements', 'regions', 'france'.</p> required <code>annee</code> <code>(str, optionnel)</code> <p>Ann\u00e9e centrale de la p\u00e9riode de 3 ans.</p> <code>None</code> <code>ordering</code> <code>(str, optionnel)</code> <p>Champ de tri.</p> <code>None</code> <code>page</code> <code>(int, optionnel)</code> <p>Page de r\u00e9sultats.</p> <code>None</code> <code>page_size</code> <code>(int, optionnel)</code> <p>Nombre de r\u00e9sultats par page.</p> <code>500</code> <code>paginate</code> <code>(bool, optionnel)</code> <p>Pagination automatique.</p> <code>True</code> <code>format_output</code> <code>(str, optionnel)</code> <p>'dataframe' ou 'dict'.</p> <code>'dataframe'</code> <code>fields</code> <code>(str, optionnel)</code> <p>'all' pour obtenir tous les champs, None sinon.</p> required <p>Returns:</p> Type Description <code>Union[DataFrame, List[dict]]</code> <p>DataFrame ou liste de dictionnaires avec les indicateurs d'activit\u00e9.</p> Source code in <code>apifoncier\\endpoints\\indicateurs.py</code> <pre><code>def activite(\n    self,\n    codes: Union[str, List[str]],\n    echelle: str,\n    annee: Optional[str] = None,\n    ordering: Optional[str] = None,\n    page: Optional[int] = None,\n    page_size: Optional[int] = 500,\n    paginate: bool = True,\n    format_output: str = \"dataframe\",\n) -&gt; Union[pd.DataFrame, List[dict]]:\n    \"\"\"\n    Renvoie les indicateurs d'activit\u00e9 du march\u00e9 tri-annuels issus de DV3F.\n\n    Args:\n        codes (str ou List[str], obligatoire): Code(s) INSEE g\u00e9ographique(s) associ\u00e9(s) \u00e0 l'\u00e9chelle (max 10).\n        echelle (str, obligatoire): 'communes', 'epci', 'aav', 'departements', 'regions', 'france'.\n        annee (str, optionnel): Ann\u00e9e centrale de la p\u00e9riode de 3 ans.\n        ordering (str, optionnel): Champ de tri.\n        page (int, optionnel): Page de r\u00e9sultats.\n        page_size (int, optionnel): Nombre de r\u00e9sultats par page.\n        paginate (bool, optionnel): Pagination automatique.\n        format_output (str, optionnel): 'dataframe' ou 'dict'.\n        fields (str, optionnel): 'all' pour obtenir tous les champs, None sinon.\n\n    Returns:\n        DataFrame ou liste de dictionnaires avec les indicateurs d'activit\u00e9.\n    \"\"\"\n    if not codes:\n        raise ValidationError(\"Le param\u00e8tre 'codes' est obligatoire\")\n    if not echelle:\n        raise ValidationError(\"Le param\u00e8tre 'echelle' est obligatoire\")\n\n    echelles_valides = [\n        \"communes\",\n        \"epci\",\n        \"aav\",\n        \"departements\",\n        \"regions\",\n        \"france\",\n    ]\n    if echelle not in echelles_valides:\n        raise ValidationError(\n            f\"L'\u00e9chelle doit \u00eatre parmi : {', '.join(echelles_valides)}\"\n        )\n\n    processed_codes = self._process_codes(codes, max_codes=10)\n\n    params = self._build_params(\n        code=processed_codes,\n        echelle=echelle,\n        annee=annee,\n        ordering=ordering,\n        page=page,\n        page_size=page_size,\n    )\n\n    return self._fetch(\n        endpoint=\"/indicateurs/dv3f/activite\",\n        params=params,\n        format_output=format_output,\n        geo=False,\n        paginate=paginate,\n    )\n</code></pre>"},{"location":"endpoints/indicateurs/#exemples-dutilisation_2","title":"Exemples d'utilisation","text":"<ul> <li>Activit\u00e9 pour une commune :   <pre><code>client.indicateurs.activite(codes=\"59001\", echelle=\"communes\")\n</code></pre></li> <li>Activit\u00e9 pour un EPCI :   <pre><code>client.indicateurs.activite(codes=\"243500139\", echelle=\"epci\")\n</code></pre></li> <li>Activit\u00e9 pour plusieurs codes :   <pre><code>client.indicateurs.activite(codes=[\"59001\", \"59002\"], echelle=\"communes\")\n</code></pre></li> </ul>"},{"location":"endpoints/indicateurs/#indicateursprix","title":"\ud83d\udcc2 <code>indicateurs.prix</code>","text":""},{"location":"endpoints/indicateurs/#description_3","title":"Description","text":"<p>Renvoie les indicateurs de prix et de volume annuels ou tri-annuels issus de DV3F.</p> <p>Parameters:</p> Name Type Description Default <code>codes</code> <code>str ou List[str], obligatoire</code> <p>Code(s) INSEE g\u00e9ographique(s) associ\u00e9(s) \u00e0 l'\u00e9chelle (max 10).</p> required <code>echelle</code> <code>(str, obligatoire)</code> <p>'communes', 'epci', 'aav', 'departements', 'regions', 'france'.</p> required <code>type_prix</code> <code>(str, optionnel)</code> <p>'annuel' ou 'triennal'.</p> <code>'annuel'</code> <code>annee</code> <code>(str, optionnel)</code> <p>Ann\u00e9e de mutation ou centrale pour triennal.</p> <code>None</code> <code>ordering</code> <code>(str, optionnel)</code> <p>Champ de tri.</p> <code>None</code> <code>page</code> <code>(int, optionnel)</code> <p>Page de r\u00e9sultats.</p> <code>None</code> <code>page_size</code> <code>(int, optionnel)</code> <p>Nombre de r\u00e9sultats par page.</p> <code>500</code> <code>paginate</code> <code>(bool, optionnel)</code> <p>Pagination automatique.</p> <code>True</code> <code>format_output</code> <code>(str, optionnel)</code> <p>'dataframe' ou 'dict'.</p> <code>'dataframe'</code> <code>fields</code> <code>(str, optionnel)</code> <p>'all' pour obtenir tous les champs, None sinon.</p> required <p>Returns:</p> Type Description <code>Union[DataFrame, List[dict]]</code> <p>DataFrame ou liste de dictionnaires avec les indicateurs de prix.</p> Source code in <code>apifoncier\\endpoints\\indicateurs.py</code> <pre><code>def prix(\n    self,\n    codes: Union[str, List[str]],\n    echelle: str,\n    type_prix: str = \"annuel\",\n    annee: Optional[str] = None,\n    ordering: Optional[str] = None,\n    page: Optional[int] = None,\n    page_size: Optional[int] = 500,\n    paginate: bool = True,\n    format_output: str = \"dataframe\",\n) -&gt; Union[pd.DataFrame, List[dict]]:\n    \"\"\"\n    Renvoie les indicateurs de prix et de volume annuels ou tri-annuels issus de DV3F.\n\n    Args:\n        codes (str ou List[str], obligatoire): Code(s) INSEE g\u00e9ographique(s) associ\u00e9(s) \u00e0 l'\u00e9chelle (max 10).\n        echelle (str, obligatoire): 'communes', 'epci', 'aav', 'departements', 'regions', 'france'.\n        type_prix (str, optionnel): 'annuel' ou 'triennal'.\n        annee (str, optionnel): Ann\u00e9e de mutation ou centrale pour triennal.\n        ordering (str, optionnel): Champ de tri.\n        page (int, optionnel): Page de r\u00e9sultats.\n        page_size (int, optionnel): Nombre de r\u00e9sultats par page.\n        paginate (bool, optionnel): Pagination automatique.\n        format_output (str, optionnel): 'dataframe' ou 'dict'.\n        fields (str, optionnel): 'all' pour obtenir tous les champs, None sinon.\n\n    Returns:\n        DataFrame ou liste de dictionnaires avec les indicateurs de prix.\n    \"\"\"\n    if not codes:\n        raise ValidationError(\"Le param\u00e8tre 'codes' est obligatoire\")\n    if not echelle:\n        raise ValidationError(\"Le param\u00e8tre 'echelle' est obligatoire\")\n    if type_prix not in [\"annuel\", \"triennal\"]:\n        raise ValidationError(\"Le type_prix doit \u00eatre 'annuel' ou 'triennal'\")\n\n    echelles_valides = [\n        \"communes\",\n        \"epci\",\n        \"aav\",\n        \"departements\",\n        \"regions\",\n        \"france\",\n    ]\n    if echelle not in echelles_valides:\n        raise ValidationError(\n            f\"L'\u00e9chelle doit \u00eatre parmi : {', '.join(echelles_valides)}\"\n        )\n\n    processed_codes = self._process_codes(codes, max_codes=10)\n\n    params = self._build_params(\n        code=processed_codes,\n        echelle=echelle,\n        annee=annee,\n        ordering=ordering,\n        page=page,\n        page_size=page_size,\n    )\n\n    return self._fetch(\n        endpoint=f\"/indicateurs/dv3f/prix/{type_prix}\",\n        params=params,\n        format_output=format_output,\n        geo=False,\n        paginate=paginate,\n    )\n</code></pre>"},{"location":"endpoints/indicateurs/#exemples-dutilisation_3","title":"Exemples d'utilisation","text":"<ul> <li>Prix annuel pour une commune :   <pre><code>client.indicateurs.prix(codes=\"59001\", echelle=\"communes\", type_prix=\"annuel\")\n</code></pre></li> <li>Prix triennal pour un d\u00e9partement :   <pre><code>client.indicateurs.prix(codes=\"62\", echelle=\"departements\", type_prix=\"triennal\")\n</code></pre></li> <li>Prix avec tri et ann\u00e9e :   <pre><code>client.indicateurs.prix(codes=[\"59350\", \"59009\"], echelle=\"communes\", ordering=\"-annee\")\n</code></pre></li> </ul>"},{"location":"endpoints/indicateurs/#indicateursvalorisation","title":"\ud83d\udcc2 <code>indicateurs.valorisation</code>","text":""},{"location":"endpoints/indicateurs/#description_4","title":"Description","text":"<p>Renvoie les indicateurs tri-annuels de valorisation d'une commune dans son AAV ou EPCI issus de DV3F.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>(str, obligatoire)</code> <p>Code INSEE de l'AAV ou de l'EPCI.</p> required <code>echelle</code> <code>(str, obligatoire)</code> <p>'aav' ou 'epci'.</p> required <code>annee</code> <code>(str, optionnel)</code> <p>Ann\u00e9e centrale de la p\u00e9riode de 3 ans.</p> <code>None</code> <code>ordering</code> <code>(str, optionnel)</code> <p>Champ de tri.</p> <code>None</code> <code>page</code> <code>(int, optionnel)</code> <p>Page de r\u00e9sultats.</p> <code>None</code> <code>page_size</code> <code>(int, optionnel)</code> <p>Nombre de r\u00e9sultats par page.</p> <code>500</code> <code>paginate</code> <code>(bool, optionnel)</code> <p>Pagination automatique.</p> <code>True</code> <code>format_output</code> <code>(str, optionnel)</code> <p>'dataframe' ou 'dict'.</p> <code>'dataframe'</code> <code>fields</code> <code>(str, optionnel)</code> <p>'all' pour obtenir tous les champs, None sinon.</p> required <p>Returns:</p> Type Description <code>Union[DataFrame, List[dict]]</code> <p>DataFrame ou liste de dictionnaires avec les indicateurs de valorisation.</p> Source code in <code>apifoncier\\endpoints\\indicateurs.py</code> <pre><code>def valorisation(\n    self,\n    code: str,\n    echelle: str,\n    annee: Optional[str] = None,\n    ordering: Optional[str] = None,\n    page: Optional[int] = None,\n    page_size: Optional[int] = 500,\n    paginate: bool = True,\n    format_output: str = \"dataframe\",\n) -&gt; Union[pd.DataFrame, List[dict]]:\n    \"\"\"\n    Renvoie les indicateurs tri-annuels de valorisation d'une commune dans son AAV ou EPCI issus de DV3F.\n\n    Args:\n        code (str, obligatoire): Code INSEE de l'AAV ou de l'EPCI.\n        echelle (str, obligatoire): 'aav' ou 'epci'.\n        annee (str, optionnel): Ann\u00e9e centrale de la p\u00e9riode de 3 ans.\n        ordering (str, optionnel): Champ de tri.\n        page (int, optionnel): Page de r\u00e9sultats.\n        page_size (int, optionnel): Nombre de r\u00e9sultats par page.\n        paginate (bool, optionnel): Pagination automatique.\n        format_output (str, optionnel): 'dataframe' ou 'dict'.\n        fields (str, optionnel): 'all' pour obtenir tous les champs, None sinon.\n\n    Returns:\n        DataFrame ou liste de dictionnaires avec les indicateurs de valorisation.\n    \"\"\"\n    if not code:\n        raise ValidationError(\"Le param\u00e8tre 'code' est obligatoire\")\n    if echelle not in [\"aav\", \"epci\"]:\n        raise ValidationError(\"L'\u00e9chelle doit \u00eatre 'aav' ou 'epci'\")\n\n    params = self._build_params(\n        annee=annee,\n        ordering=ordering,\n        page=page,\n        page_size=page_size,\n    )\n\n    return self._fetch(\n        endpoint=f\"/indicateurs/dv3f/valorisation/{echelle}/{code}\",\n        params=params,\n        format_output=format_output,\n        geo=False,\n        paginate=paginate,\n    )\n</code></pre>"},{"location":"endpoints/indicateurs/#exemples-dutilisation_4","title":"Exemples d'utilisation","text":"<ul> <li>Valorisation pour une AAV :   <pre><code>client.indicateurs.valorisation(code=\"004\", echelle=\"aav\")\n</code></pre></li> <li>Valorisation pour un EPCI :   <pre><code>client.indicateurs.valorisation(code=\"243500139\", echelle=\"epci\")\n</code></pre></li> <li>Valorisation pour une ann\u00e9e donn\u00e9e :   <pre><code>client.indicateurs.valorisation(code=\"005\", echelle=\"aav\", annee=\"2021\")\n</code></pre></li> </ul>"},{"location":"examples/exemple_cartofriches/","title":"Exemples sur Cartofriches","text":"In\u00a0[3]: Copied! <pre>import plotly.io as pio\nimport plotly.express as px\n\npio.renderers.default = \"notebook\"\n\nfrom apifoncier import ApiFoncierClient\n</pre> import plotly.io as pio import plotly.express as px  pio.renderers.default = \"notebook\"  from apifoncier import ApiFoncierClient In\u00a0[\u00a0]: Copied! <pre># On r\u00e9cup\u00e8re les friches du d\u00e9partement 59\nwith ApiFoncierClient({\"base_url\": \"https://apidf.k8-dev.cerema.fr\"}) as apidf:\n    friches = apidf.cartofriches.friches(coddep=\"59\", limit=1000)\n</pre> # On r\u00e9cup\u00e8re les friches du d\u00e9partement 59 with ApiFoncierClient({\"base_url\": \"https://apidf.k8-dev.cerema.fr\"}) as apidf:     friches = apidf.cartofriches.friches(coddep=\"59\", limit=1000) <pre>/cartofriches/friches: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1472/1472 [00:00&lt;00:00, 2909.85enreg./s]\n</pre> In\u00a0[5]: Copied! <pre># D\u00e9compte par commune\nresult = friches.value_counts(\"comm_nom\").to_frame(\"nb_friches\").iloc[:15]\n\n# G\u00e9n\u00e9ration du graphique\nfig = px.bar(\n    result,\n    \"nb_friches\",\n    labels={\"nb_friches\": \"Nombre de friches\", \"comm_nom\": \"Communes\"},\n    title=\"Communes ayant le + de friches dans le d\u00e9partement du Nord\",\n)\nfig.show()\n</pre> # D\u00e9compte par commune result = friches.value_counts(\"comm_nom\").to_frame(\"nb_friches\").iloc[:15]  # G\u00e9n\u00e9ration du graphique fig = px.bar(     result,     \"nb_friches\",     labels={\"nb_friches\": \"Nombre de friches\", \"comm_nom\": \"Communes\"},     title=\"Communes ayant le + de friches dans le d\u00e9partement du Nord\", ) fig.show() In\u00a0[8]: Copied! <pre>import folium\n\nwith ApiFoncierClient({\"base_url\": \"https://apidf.k8-dev.cerema.fr\"}) as apidf:\n    gdf = apidf.cartofriches.geofriches(in_bbox=[3, 50, 3.5, 50.5])\n    geojson = gdf.to_json()\n\nm = folium.Map(location=[50.25, 3.25], zoom_start=12)\n# Ajouter les donn\u00e9es GeoJSON \u00e0 la carte Folium\nfolium.GeoJson(geojson).add_to(m)\n# Afficher la carte\nm\n</pre> import folium  with ApiFoncierClient({\"base_url\": \"https://apidf.k8-dev.cerema.fr\"}) as apidf:     gdf = apidf.cartofriches.geofriches(in_bbox=[3, 50, 3.5, 50.5])     geojson = gdf.to_json()  m = folium.Map(location=[50.25, 3.25], zoom_start=12) # Ajouter les donn\u00e9es GeoJSON \u00e0 la carte Folium folium.GeoJson(geojson).add_to(m) # Afficher la carte m <pre>/cartofriches/geofriches: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 402/402 [00:00&lt;00:00, 10993.24enreg./s]\n</pre> Out[8]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook"},{"location":"examples/exemple_cartofriches/#exemples-sur-cartofriches","title":"Exemples sur Cartofriches\u00b6","text":""},{"location":"examples/exemple_cartofriches/#communes-ayant-le-plus-de-friches-identifiees-sur-un-departement","title":"Communes ayant le plus de friches identifi\u00e9es sur un d\u00e9partement\u00b6","text":""},{"location":"examples/exemple_cartofriches/#affichage-des-friches-dans-une-emprise-rectangulaire","title":"Affichage des friches dans une emprise rectangulaire\u00b6","text":""},{"location":"examples/gallery/","title":"Pr\u00e9sentation","text":""},{"location":"examples/gallery/#exemples-dusage-dapifoncier","title":"Exemples d'usage d'<code>apifoncier</code>","text":"<p>Voici quelques exemples d'utilisation de la biblioth\u00e8que <code>apifoncier</code> pour interagir avec les endpoints disponibles. Ces exemples couvrent essentiellement les endpoints ouverts.</p>"},{"location":"quickstart/installation/","title":"Installation","text":""},{"location":"quickstart/installation/#prerequis","title":"Pr\u00e9requis","text":"<ul> <li>Python \u2265 3.10 recommand\u00e9</li> <li>pip</li> </ul>"},{"location":"quickstart/installation/#installation-du-package","title":"Installation du package","text":"<pre><code>pip install apifoncier2\n</code></pre>"},{"location":"quickstart/installation/#installation-depuis-le-depot-git","title":"Installation depuis le d\u00e9p\u00f4t Git","text":"<pre><code>git clone https://github.com/aherman59/apifoncier.git\ncd apifoncier\npip install .\n</code></pre>"},{"location":"quickstart/installation/#dependances-principales","title":"D\u00e9pendances principales","text":"<ul> <li>requests</li> <li>pandas</li> <li>geopandas</li> </ul> <p>Les d\u00e9pendances sont install\u00e9es automatiquement avec le package.</p>"},{"location":"quickstart/installation/#mise-a-jour","title":"Mise \u00e0 jour","text":"<pre><code>pip install --upgrade apifoncier2\n</code></pre>"},{"location":"quickstart/quickstart/","title":"Quelques exemples pour d\u00e9marrer","text":"In\u00a0[\u00a0]: Copied! <pre># Import le client pour interagir avec l'API\nfrom apifoncier import ApiFoncierClient\n\nimport plotly.io as pio\n\npio.renderers.default = \"notebook\"\n</pre> # Import le client pour interagir avec l'API from apifoncier import ApiFoncierClient  import plotly.io as pio  pio.renderers.default = \"notebook\" In\u00a0[2]: Copied! <pre># On instancie le client\nclient = ApiFoncierClient()\n\n# Exemples sur Cartofriches (commune de Lille)\nfriches = client.cartofriches.friches(code_insee=\"59350\")\n\n# Affichage des 5 premi\u00e8res friches du dataframe\nfriches.head()\n</pre> # On instancie le client client = ApiFoncierClient()  # Exemples sur Cartofriches (commune de Lille) friches = client.cartofriches.friches(code_insee=\"59350\")  # Affichage des 5 premi\u00e8res friches du dataframe friches.head() <pre>/cartofriches/friches: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 138/138 [00:00&lt;00:00, 69054.40enreg./s]\n</pre> Out[2]: site_id site_nom site_type site_adresse site_statut comm_nom comm_insee dep proprio_personne unite_fonciere_surface unite_fonciere_refcad source_nom nature urba_zone_type 0 59350_10190 Teinturerie inconnu None friche potentielle LILLE 59350 59 personne morale 234.171185 ['59350000IK0025'] Site Basias ou Basol non v\u00e9rifi\u00e9 par le Cerema MTE non v\u00e9rifi\u00e9 U 1 59350_10192 WILVIA MEUBLEX inconnu None friche potentielle LILLE 59350 59 personne morale 234.171185 ['59350000IK0025'] Site Basias ou Basol non v\u00e9rifi\u00e9 par le Cerema MTE non v\u00e9rifi\u00e9 U 2 59350_10209 Atelier de m\u00e9canique inconnu None friche potentielle LILLE 59350 59 personne morale 234.171185 ['59350000IK0025'] Site Basias ou Basol non v\u00e9rifi\u00e9 par le Cerema MTE non v\u00e9rifi\u00e9 U 3 59350_10210 Station Service Esso inconnu None friche potentielle LILLE 59350 59 personne morale 234.171185 ['59350000IK0025'] Site Basias ou Basol non v\u00e9rifi\u00e9 par le Cerema MTE non v\u00e9rifi\u00e9 U 4 59350_10211 Assitance et Inspection Techniques inconnu None friche potentielle LILLE 59350 59 personne morale 234.171185 ['59350000IK0025'] Site Basias ou Basol non v\u00e9rifi\u00e9 par le Cerema MTE non v\u00e9rifi\u00e9 U In\u00a0[3]: Copied! <pre># Equivalent avec un context-manager\nwith ApiFoncierClient() as client:\n    friches = client.cartofriches.friches(code_insee=\"59350\")\n\nfriches.head()\n</pre> # Equivalent avec un context-manager with ApiFoncierClient() as client:     friches = client.cartofriches.friches(code_insee=\"59350\")  friches.head() <pre>/cartofriches/friches: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 138/138 [00:00&lt;00:00, 135047.59enreg./s]\n</pre> Out[3]: site_id site_nom site_type site_adresse site_statut comm_nom comm_insee dep proprio_personne unite_fonciere_surface unite_fonciere_refcad source_nom nature urba_zone_type 0 59350_10190 Teinturerie inconnu None friche potentielle LILLE 59350 59 personne morale 234.171185 ['59350000IK0025'] Site Basias ou Basol non v\u00e9rifi\u00e9 par le Cerema MTE non v\u00e9rifi\u00e9 U 1 59350_10192 WILVIA MEUBLEX inconnu None friche potentielle LILLE 59350 59 personne morale 234.171185 ['59350000IK0025'] Site Basias ou Basol non v\u00e9rifi\u00e9 par le Cerema MTE non v\u00e9rifi\u00e9 U 2 59350_10209 Atelier de m\u00e9canique inconnu None friche potentielle LILLE 59350 59 personne morale 234.171185 ['59350000IK0025'] Site Basias ou Basol non v\u00e9rifi\u00e9 par le Cerema MTE non v\u00e9rifi\u00e9 U 3 59350_10210 Station Service Esso inconnu None friche potentielle LILLE 59350 59 personne morale 234.171185 ['59350000IK0025'] Site Basias ou Basol non v\u00e9rifi\u00e9 par le Cerema MTE non v\u00e9rifi\u00e9 U 4 59350_10211 Assitance et Inspection Techniques inconnu None friche potentielle LILLE 59350 59 personne morale 234.171185 ['59350000IK0025'] Site Basias ou Basol non v\u00e9rifi\u00e9 par le Cerema MTE non v\u00e9rifi\u00e9 U In\u00a0[4]: Copied! <pre># Jeton API pour authentification sur les endpoints restreints de l'API\ntoken = \"votre_jeton_api_ici\"\n\n# Dictionnaire pour la configuration du client\nconfig = {\n    \"api_key\": token,\n    \"progress_bar\": False,  # D\u00e9sactive la barre de progression\n    \"timeout\": 10,  # D\u00e9lai d'attente pour les requ\u00eates en secondes\n    \"max_retries\": 3,  # Nombre maximum de tentatives en cas d'\u00e9chec\n    \"base_url\": \"https://apidf.k8-dev.cerema.fr\",\n}\n\n# Instanciation du client avec la configuration\nclient = ApiFoncierClient(config)\n\n# ou\nwith ApiFoncierClient(config) as client:\n    pass\n</pre> # Jeton API pour authentification sur les endpoints restreints de l'API token = \"votre_jeton_api_ici\"  # Dictionnaire pour la configuration du client config = {     \"api_key\": token,     \"progress_bar\": False,  # D\u00e9sactive la barre de progression     \"timeout\": 10,  # D\u00e9lai d'attente pour les requ\u00eates en secondes     \"max_retries\": 3,  # Nombre maximum de tentatives en cas d'\u00e9chec     \"base_url\": \"https://apidf.k8-dev.cerema.fr\", }  # Instanciation du client avec la configuration client = ApiFoncierClient(config)  # ou with ApiFoncierClient(config) as client:     pass In\u00a0[5]: Copied! <pre># R\u00e9cup\u00e9ration des transactions pour une commune sp\u00e9cifique (ici, Rouen) issues de DVF+ open-data\nmutations = client.dvf_opendata.mutations(\n    code_insee=\"76540\", anneemut_min=2020, anneemut_max=2024\n)\n\n# R\u00e9partition des mutations selon le type de bien\nprint(\"Nombre de mutations sur la p\u00e9riode 2020-2024: \", mutations.shape[0])\nmutations.value_counts(\"libtypbien\")\n</pre> # R\u00e9cup\u00e9ration des transactions pour une commune sp\u00e9cifique (ici, Rouen) issues de DVF+ open-data mutations = client.dvf_opendata.mutations(     code_insee=\"76540\", anneemut_min=2020, anneemut_max=2024 )  # R\u00e9partition des mutations selon le type de bien print(\"Nombre de mutations sur la p\u00e9riode 2020-2024: \", mutations.shape[0]) mutations.value_counts(\"libtypbien\") <pre>Nombre de mutations sur la p\u00e9riode 2020-2024:  16885\n</pre> Out[5]: <pre>libtypbien\nUN APPARTEMENT                               10347\nUNE MAISON                                    1909\nBATI - INDETERMINE : Vefa sans descriptif     1182\nACTIVITE                                      1003\nUNE DEPENDANCE                                 791\nAPPARTEMENT INDETERMINE                        400\nBATI MIXTE - LOGEMENT/ACTIVITE                 349\nDEUX APPARTEMENTS                              333\nDES DEPENDANCES                                182\nTERRAIN ARTIFICIALISE MIXTE                    134\nBATI - INDETERMINE : Vente avec volume(s)      126\nDES MAISONS                                     49\nTERRAIN DE TYPE TAB                             36\nBATI MIXTE - LOGEMENTS                          27\nTERRAIN DE TYPE RESEAU                           4\nTERRAIN D'AGREMENT                               4\nTERRAIN NON BATIS INDETERMINE                    4\nTERRAIN FORESTIER                                2\nTERRAIN VERGER                                   2\nTERRAIN LANDES ET EAUX                           1\nName: count, dtype: int64</pre> In\u00a0[6]: Copied! <pre># R\u00e9cup\u00e9ration des indicateurs de prix pour des communes en 2024\nprix = client.indicateurs.prix(\n    codes=[\n        \"75056\",  # Paris\n        \"13055\",  # Marseille\n        \"69123\",  # Lyon\n        \"31555\",  # Toulouse\n        \"06088\",  # Nice\n        \"44109\",  # Nantes\n        \"34172\",  # Montpellier\n        \"67482\",  # Strasbourg\n        \"33063\",  # Bordeaux\n        \"59350\",  # Lille\n    ],\n    echelle=\"communes\",\n    annee=\"2024\",\n    type_prix=\"annuel\",\n)\n\n# Affichage des prix m\u00e9dians au m\u00b2 des appartements anciens pour les principales villes fran\u00e7aises\nprix[[\"libelle\", \"annee\", \"pxm2_median_cod1213\"]].sort_values(\n    \"pxm2_median_cod1213\", ascending=False\n).rename(\n    columns={\n        \"libelle\": \"Commune\",\n        \"annee\": \"Ann\u00e9e\",\n        \"pxm2_median_cod1213\": \"Prix m\u00e9dian (\u20ac/m2)\",\n    }\n)\n</pre> # R\u00e9cup\u00e9ration des indicateurs de prix pour des communes en 2024 prix = client.indicateurs.prix(     codes=[         \"75056\",  # Paris         \"13055\",  # Marseille         \"69123\",  # Lyon         \"31555\",  # Toulouse         \"06088\",  # Nice         \"44109\",  # Nantes         \"34172\",  # Montpellier         \"67482\",  # Strasbourg         \"33063\",  # Bordeaux         \"59350\",  # Lille     ],     echelle=\"communes\",     annee=\"2024\",     type_prix=\"annuel\", )  # Affichage des prix m\u00e9dians au m\u00b2 des appartements anciens pour les principales villes fran\u00e7aises prix[[\"libelle\", \"annee\", \"pxm2_median_cod1213\"]].sort_values(     \"pxm2_median_cod1213\", ascending=False ).rename(     columns={         \"libelle\": \"Commune\",         \"annee\": \"Ann\u00e9e\",         \"pxm2_median_cod1213\": \"Prix m\u00e9dian (\u20ac/m2)\",     } ) Out[6]: Commune Ann\u00e9e Prix m\u00e9dian (\u20ac/m2) 8 Paris 2024 9835.290 0 Nice 2024 4893.620 7 Lyon 2024 4555.560 3 Bordeaux 2024 4346.940 2 Toulouse 2024 3685.710 6 Lille 2024 3621.670 4 Montpellier 2024 3541.840 5 Nantes 2024 3482.425 1 Marseille 2024 3305.115 In\u00a0[7]: Copied! <pre># R\u00e9cup\u00e9ration des indicateurs de consommation d'espace pour la commune d'Arras (code INSEE 62041)\nconso_espace = client.indicateurs.conso(\n    code=\"62041\",\n    annee_min=2010,\n    echelle=\"communes\",\n)\n\n# Affichage des surfaces artificialis\u00e9es pour la commune d'Arras\nconso_espace[[\"annee\", \"idcomtxt\", \"naf_arti\"]].rename(\n    columns={\n        \"idcomtxt\": \"Nom de la commune\",\n        \"naf_arti\": \"Surface artificialis\u00e9e (m2)\",\n        \"annee\": \"Ann\u00e9e\",\n    }\n)\n</pre> # R\u00e9cup\u00e9ration des indicateurs de consommation d'espace pour la commune d'Arras (code INSEE 62041) conso_espace = client.indicateurs.conso(     code=\"62041\",     annee_min=2010,     echelle=\"communes\", )  # Affichage des surfaces artificialis\u00e9es pour la commune d'Arras conso_espace[[\"annee\", \"idcomtxt\", \"naf_arti\"]].rename(     columns={         \"idcomtxt\": \"Nom de la commune\",         \"naf_arti\": \"Surface artificialis\u00e9e (m2)\",         \"annee\": \"Ann\u00e9e\",     } ) Out[7]: Ann\u00e9e Nom de la commune Surface artificialis\u00e9e (m2) 0 2010 Arras 6782 1 2011 Arras 6820 2 2012 Arras 37627 3 2013 Arras 260499 4 2014 Arras 15198 5 2015 Arras 15888 6 2016 Arras 20942 7 2017 Arras 19079 8 2018 Arras 44201 9 2019 Arras 53291 10 2020 Arras 4665 11 2021 Arras 0 12 2022 Arras 2974 13 2023 Arras 1710 In\u00a0[8]: Copied! <pre># R\u00e9cup\u00e9ration des friches au format geojson pour la Moselle\ngeofriches = client.cartofriches.geofriches(coddep=\"57\", format_output=\"dict\")\n\n# Affichage de la carte avec les friches\n# (n\u00e9cessite la biblioth\u00e8que folium)\nimport folium\n\nm = folium.Map(location=[49.1193, 6.1752], zoom_start=11)\nfolium.GeoJson(\n    data=geofriches,  # Dictionnaire GeoJSON\n    name=\"Friches\",\n    style_function=lambda x: {\n        \"color\": \"darkred\",\n        \"weight\": 1,\n        \"fillOpacity\": 0.5,\n    },\n    tooltip=folium.features.GeoJsonTooltip(\n        fields=[\"site_nom\"],\n        aliases=[\"Nom:\"],\n    ),\n).add_to(m)\nm\n</pre> # R\u00e9cup\u00e9ration des friches au format geojson pour la Moselle geofriches = client.cartofriches.geofriches(coddep=\"57\", format_output=\"dict\")  # Affichage de la carte avec les friches # (n\u00e9cessite la biblioth\u00e8que folium) import folium  m = folium.Map(location=[49.1193, 6.1752], zoom_start=11) folium.GeoJson(     data=geofriches,  # Dictionnaire GeoJSON     name=\"Friches\",     style_function=lambda x: {         \"color\": \"darkred\",         \"weight\": 1,         \"fillOpacity\": 0.5,     },     tooltip=folium.features.GeoJsonTooltip(         fields=[\"site_nom\"],         aliases=[\"Nom:\"],     ), ).add_to(m) m Out[8]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook"},{"location":"quickstart/quickstart/#quelques-exemples-pour-demarrer","title":"Quelques exemples pour d\u00e9marrer\u00b6","text":""},{"location":"quickstart/quickstart/#utilisation-du-client","title":"Utilisation du client\u00b6","text":""},{"location":"quickstart/quickstart/#configuration-du-client","title":"Configuration du client\u00b6","text":""},{"location":"quickstart/quickstart/#exemples-dutilisation","title":"Exemples d'utilisation\u00b6","text":""},{"location":"quickstart/usage/","title":"Usage","text":""},{"location":"quickstart/usage/#initialisation-du-client","title":"Initialisation du client","text":"<pre><code>from apifoncier.client import ApiFoncierClient\n\nconfig = {\n    \"api_key\": \"VOTRE_CLE_API\",  # Facultatif - uniquement pour l'utilisation des endpoints restreints\n    \"progress_bar\": False,  # Afficher la barre de progression (True/False - True par d\u00e9faut)\n}\n\nclient = ApiFoncierClient(config)\n</code></pre>"},{"location":"quickstart/usage/#exemple-de-requete","title":"Exemple de requ\u00eate","text":"<pre><code># Endpoint ouvert\nresult = client.dvf_opendata.mutations(code_insee=\"59001\")\n\n# Endpoint restreint (cl\u00e9 API requise)\nresult = client.ff.parcelles(code_insee=\"62001\")\n</code></pre>"},{"location":"quickstart/usage/#utilisation-avec-le-contexte","title":"Utilisation avec le contexte","text":"<pre><code>with ApiFoncierClient(config) as client:\n    data = client.cartofriches.friches(code_insee=\"62001\")\n</code></pre>"},{"location":"quickstart/usage/#format-des-resultats","title":"Format des r\u00e9sultats","text":"<ul> <li>Par d\u00e9faut, le format renvoy\u00e9 est un DataFrame pandas ou GeoDataFrame geopandas (<code>format_output=\"dataframe\"</code>) .</li> <li>Les donn\u00e9es peuvent \u00e9galement \u00eatre r\u00e9cup\u00e9r\u00e9es sous la forme d'une liste de dictionnaires (<code>format_output=\"dict\"</code>)</li> </ul>"},{"location":"quickstart/usage/#pagination","title":"Pagination","text":"<p>La pagination est g\u00e9r\u00e9e automatiquement. Par d\u00e9faut (<code>paginate=True</code>), toutes les pages sont interrog\u00e9es.</p> <p>Vous pouvez d\u00e9sactiver la pagination (<code>paginate=False</code>) pour renvoyer uniquement la premi\u00e8re page et ajuster la taille de page avec <code>page_size</code>.</p>"},{"location":"quickstart/usage/#documentation-des-endpoints","title":"Documentation des endpoints","text":"<p>Consultez les fiches d\u00e9di\u00e9es pour chaque endpoint dans la section \"Endpoints\" de la documentation.</p>"}]}